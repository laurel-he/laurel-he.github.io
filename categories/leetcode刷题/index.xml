<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode刷题 on </title>
    <link>https://laurel-he.github.io/categories/leetcode%E5%88%B7%E9%A2%98/</link>
    <description>Recent content in Leetcode刷题 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 03 Sep 2021 19:10:10 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/categories/leetcode%E5%88%B7%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>26. 删除有序数组中的重复项</title>
      <link>https://laurel-he.github.io/acm/leetcode/26removeduplicates/</link>
      <pubDate>Fri, 03 Sep 2021 19:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/26removeduplicates/</guid>
      <description>题目来源26. 删除有序数组中的重复项
题目描述 难度 简单
描述 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明: 为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &amp;lt; len; i++) {print(nums[i]);}示例 1： 输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2： 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</description>
    </item>
    
    <item>
      <title>36. 有效的数独</title>
      <link>https://laurel-he.github.io/acm/leetcode/36effecttivesudoku/</link>
      <pubDate>Fri, 03 Sep 2021 19:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/36effecttivesudoku/</guid>
      <description>题目来源：36. 有效的数独
描述 请你判断一个9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字1-9在每一行只能出现一次。 数字1-9在每一列只能出现一次。 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用&#39;.&amp;lsquo;表示。
注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。
示例 1： 输入：board = [[&amp;ldquo;5&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;] ,[&amp;ldquo;4&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;] ,[&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;5&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;9&amp;rdquo;]] 输出：true
示例 2： 输入：board = [[&amp;ldquo;8&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;] ,[&amp;ldquo;4&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;] ,[&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;5&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;9&amp;rdquo;]] 输出：false 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 &amp;lsquo;.&amp;rsquo;
自行解法 class Solution { /** * @param String[][] $board * @return Boolean */ function isValidSudoku($board) { $nineArr = [ [ $board[0][0], $board[0][1], $board[0][2], $board[1][0], $board[1][1], $board[1][2], $board[2][0], $board[2][1], $board[2][2]], [ $board[3][0], $board[3][1], $board[3][2], $board[4][0], $board[4][1], $board[4][2], $board[5][0], $board[5][1], $board[5][2], ], [ $board[6][0], $board[6][1], $board[6][2], $board[7][0], $board[7][1], $board[7][2], $board[8][0], $board[8][1], $board[8][2], ], [ $board[0][3], $board[0][4], $board[0][5], $board[1][3], $board[1][4], $board[1][5], $board[2][3], $board[2][4], $board[2][5]], [ $board[3][3], $board[3][4], $board[3][5], $board[4][3], $board[4][4], $board[4][5], $board[5][3], $board[5][4], $board[5][5], ], [ $board[6][3], $board[6][4], $board[6][5], $board[7][3], $board[7][4], $board[7][5], $board[8][3], $board[8][4], $board[8][5], ], [ $board[0][6], $board[0][7], $board[0][8], $board[1][6], $board[1][7], $board[1][8], $board[2][6], $board[2][7], $board[2][8]], [ $board[3][6], $board[3][7], $board[3][8], $board[4][6], $board[4][7], $board[4][8], $board[5][6], $board[5][7], $board[5][8], ], [ $board[6][6], $board[6][7], $board[6][8], $board[7][6], $board[7][7], $board[7][8], $board[8][6], $board[8][7], $board[8][8], ], ]; foreach ($nineArr as $checkNine) { if (!</description>
    </item>
    
    <item>
      <title>118. 杨辉三角</title>
      <link>https://laurel-he.github.io/acm/leetcode/118pascalstriangle/</link>
      <pubDate>Fri, 03 Sep 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/118pascalstriangle/</guid>
      <description>题目来源：118. 杨辉三角
题目描述 给定一个非负整数numRows，生成「杨辉三角」的前numRows行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
示例2: 输入: numRows = 1 输出: [[1]]
提示: 1 &amp;lt;= numRows &amp;lt;= 30
自行解法 可以判断出以下结论： （1）每一项的第一个和最后一个都是1 （2）每一项的个数等于所在项的位置 （3）每一项除开第一个和最后一个数字，假设所在位置为i，其他的数字应该等于上一项的i-1和i下标的值之和 根据以上结论可以实现如下代码：
class Solution { /** * @param Integer $numRows * @return Integer[][] */ function generate($numRows) { $ret = []; for ($i = 0; $i &amp;lt; $numRows; $i++) { $cont = []; for ($j = 0; $j &amp;lt; $i + 1; $j ++) { if ($j == 0 || $j == $i) { $cont[$j] = 1; } else { $cont[$j] = $ret[$i - 1][$j - 1] + $ret[$i - 1][$j]; } } $ret[$i] = $cont; } return $ret; } } 其他优质解法分析 </description>
    </item>
    
    <item>
      <title>88.合并两个有序数组</title>
      <link>https://laurel-he.github.io/acm/leetcode/88arraymerge/</link>
      <pubDate>Wed, 01 Sep 2021 18:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/88arraymerge/</guid>
      <description>题目来源：88.合并两个有序数组
描述 给你两个按 非递减顺序 排列的整数数组nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。</description>
    </item>
    
    <item>
      <title>1.两数之和</title>
      <link>https://laurel-he.github.io/acm/leetcode/1towsum/</link>
      <pubDate>Wed, 01 Sep 2021 12:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/1towsum/</guid>
      <description>题目链接：1.两数之和
题目描述 难度 简单 描述 给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2]
示例 3： 输入：nums = [3,3], target = 6 输出：[0,1]
提示：
2 &amp;lt;= nums.length &amp;lt;= 104 -109 &amp;lt;= nums[i] &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 只会存在一个有效答案 进阶： 你可以想出一个时间复杂度小于 O(n2) 的算法吗？</description>
    </item>
    
    <item>
      <title>53.最大子序和</title>
      <link>https://laurel-he.github.io/acm/leetcode/53maxsum/</link>
      <pubDate>Tue, 31 Aug 2021 17:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/53maxsum/</guid>
      <description>题目链接：53.最大子序和
题目描述 难度 简单 描述 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组[4,-1,2,1] 的和最大，为6 。
示例 2： 输入：nums = [1] 输出：1
示例 3： 输入：nums = [0] 输出：0
示例 4： 输入：nums = [-1] 输出：-1
示例 5： 输入：nums = [-100000] 输出：-100000
提示： 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 105
进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
自行解法 一开始并没有想到合适的解法，于是想到最暴力的方式，获取所有子序和并比较
class Solution { /** * 出所有的子序和之后进行比较 * @param Integer[] $nums * @return Integer */ function maxSubArray($nums) { $maxForI = []; for ($i = 0; $i &amp;lt; count($nums); $i++) { $sumForI = $nums[$i]; $maxForJ = []; $max = max($nums); for ($j = $i + 1; $j &amp;lt; count($nums); $j++) { if ($i == $j) { $sumForI = $nums[$i]; } else { $sumForI += $nums[$j]; } $maxForJ[] = max($maxNum, $sumForI, $max); $maxNum = $sumForI; } if (count($nums) == 1) { $maxForJ = $nums; } $maxForI[$i] = max($maxForJ); } return max($maxForI); } } 这种方式可以通过绝大部分测试用例，但是当$nums增加到一定数量级后会超时</description>
    </item>
    
    <item>
      <title>122. 买卖股票的最佳时机</title>
      <link>https://laurel-he.github.io/acm/leetcode/121buyshares/</link>
      <pubDate>Tue, 31 Aug 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/121buyshares/</guid>
      <description>题目链接：122. 买卖股票的最佳时机
题目描述 难度 简单 描述 给定一个数组 prices ，它的第i 个元素prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
提示： 1 &amp;lt;= prices.length &amp;lt;= 105 0 &amp;lt;= prices[i] &amp;lt;= 104
自行解法 暴力解法 暴力解法虽然可以实现，但当数组超出一定长度时会超时
class Solution { /** * @param Integer[] $prices * @return Integer */ function maxProfit($prices) { $countPri = count($prices); $diff = []; for ($i = 0; $i &amp;lt; $countPri; $i++) { $maxDiff = 0; for ($j = $i + 1; $j &amp;lt; $countPri; $j ++) { if ($prices[$j] - $prices[$i] &amp;gt; $maxDiff) { $maxDiff = ($prices[$j] - $prices[$i]); } } $diff[] = $maxDiff; } return max($diff); } } 动态规划(DP)：</description>
    </item>
    
    <item>
      <title>1175. 质数排列</title>
      <link>https://laurel-he.github.io/acm/leetcode/1175primesort/</link>
      <pubDate>Thu, 03 Sep 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/1175primesort/</guid>
      <description>题目来源:1175. 质数排列
题目描述 难度 简单
描述 请你帮忙给从 1 到 n的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。
让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。
由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。
 示例 1：
输入：n = 5 输出：12 解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。 示例 2：
输入：n = 100 输出：682289015
提示：
1 &amp;lt;= n &amp;lt;= 100
自我解法 </description>
    </item>
    
    <item>
      <title>566. 重塑矩阵</title>
      <link>https://laurel-he.github.io/acm/leetcode/566remouldmatrix/</link>
      <pubDate>Thu, 03 Sep 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/566remouldmatrix/</guid>
      <description>题目来源:566. 重塑矩阵
题目描述 难度 简单
描述 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。
给你一个由二维数组 mat 表示的m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。
重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。
如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。
示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]]
示例 2： 输入：mat = [[1,2],[3,4]], r = 2, c = 4 输出：[[1,2],[3,4]]
提示： m == mat.length n == mat[i].length 1 &amp;lt;= m, n &amp;lt;= 100 -1000 &amp;lt;= mat[i][j] &amp;lt;= 1000 1 &amp;lt;= r, c &amp;lt;= 300</description>
    </item>
    
    <item>
      <title>350. 两个数组的交集 II</title>
      <link>https://laurel-he.github.io/acm/leetcode/350arrat/</link>
      <pubDate>Wed, 02 Sep 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/350arrat/</guid>
      <description>题目链接350. 两个数组的交集 II
题目描述 难度 简单
描述 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2]
示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9]
说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。
进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果nums1的大小比nums2小很多，哪种方法更优？ 如果nums2的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
自行解法 思路 这里需要获取两个数组的交集，php有一个函数（array_intersect）可以获取两个数组的交集，但是和要求不符合。 当某个元素在数组a中存在，且在数组b中存在不止一次，array_intersect获得的交集不正确。 因此分析，可以直接循环较短的数组，和另一个较长的数组比较，当获得了一个交集元素的时候，就删除被比较的元素，代码如下：
class Solution { function delOneFromArr($val, $delArr) { /** 删除数组中一个值为$val的数据 */ foreach($delArr as $key =&amp;gt; $arr) { if ($arr == $val) { unset($delArr[$key]); break; } } return $delArr; } /** * @param Integer[] $nums1 * @param Integer[] $nums2 * @return Integer[] */ function intersect($nums1, $nums2) { /** 循环较短的数组，挨个判断 */ list($checkArr, $otherArr) = count($nums1) &amp;gt;= count($nums2) ?</description>
    </item>
    
    <item>
      <title>217.存在重复元素</title>
      <link>https://laurel-he.github.io/acm/leetcode/217repeat/</link>
      <pubDate>Mon, 31 Aug 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/217repeat/</guid>
      <description>题目链接：217.存在重复元素
题目描述 难度 简单 描述 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1: 输入: [1,2,3,1] 输出: true
示例 2: 输入: [1,2,3,4] 输出: false
示例3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
自行解法 直接循环，判断每个元素和剩余的其他元素是否重复，不重复则去除这个元素，继续比较
class Solution { /** * @param Integer[] $nums * @return Boolean */ function containsDuplicate($nums) { $dataCheck = $nums; for ($i = 0; $i &amp;lt; count($nums); $i++) { $check = $nums[$i]; unset($dataCheck[$i]); if (in_array($check, $dataCheck)) { return true; } } return false; } } 其他优质解法 先去重，判断去重后的长度是否比之前的长度短，是则说明有重复</description>
    </item>
    
  </channel>
</rss>
