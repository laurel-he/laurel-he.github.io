<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode刷题 on </title>
    <link>https://laurel-he.github.io/categories/leetcode%E5%88%B7%E9%A2%98/</link>
    <description>Recent content in Leetcode刷题 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 02 Sep 2021 16:10:10 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/categories/leetcode%E5%88%B7%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>350. 两个数组的交集 II</title>
      <link>https://laurel-he.github.io/acm/leetcode/350arrat/</link>
      <pubDate>Thu, 02 Sep 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/350arrat/</guid>
      <description>题目链接350. 两个数组的交集 II
题目描述 难度 简单
描述 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2]
示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9]
说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。
进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果nums1的大小比nums2小很多，哪种方法更优？ 如果nums2的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
自行解法 思路 这里需要获取两个数组的交集，php有一个函数（array_intersect）可以获取两个数组的交集，但是和要求不符合。 当某个元素在数组a中存在，且在数组b中存在不止一次，array_intersect获得的交集不正确。 因此分析，可以直接循环较短的数组，和另一个较长的数组比较，当获得了一个交集元素的时候，就删除被比较的元素，代码如下：
class Solution { function delOneFromArr($val, $delArr) { /** 删除数组中一个值为$val的数据 */ foreach($delArr as $key =&amp;gt; $arr) { if ($arr == $val) { unset($delArr[$key]); break; } } return $delArr; } /** * @param Integer[] $nums1 * @param Integer[] $nums2 * @return Integer[] */ function intersect($nums1, $nums2) { /** 循环较短的数组，挨个判断 */ list($checkArr, $otherArr) = count($nums1) &amp;gt;= count($nums2) ?</description>
    </item>
    
    <item>
      <title>88.合并两个有序数组</title>
      <link>https://laurel-he.github.io/acm/leetcode/88arraymerge/</link>
      <pubDate>Wed, 01 Sep 2021 18:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/88arraymerge/</guid>
      <description>题目来源：88.合并两个有序数组
描述 给你两个按 非递减顺序 排列的整数数组nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。</description>
    </item>
    
    <item>
      <title>1.两数之和</title>
      <link>https://laurel-he.github.io/acm/leetcode/1towsum/</link>
      <pubDate>Wed, 01 Sep 2021 12:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/1towsum/</guid>
      <description>题目链接：1.两数之和
题目描述 难度 简单 描述 给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2]
示例 3： 输入：nums = [3,3], target = 6 输出：[0,1]
提示：
2 &amp;lt;= nums.length &amp;lt;= 104 -109 &amp;lt;= nums[i] &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 只会存在一个有效答案 进阶： 你可以想出一个时间复杂度小于 O(n2) 的算法吗？</description>
    </item>
    
    <item>
      <title>53.最大子序和</title>
      <link>https://laurel-he.github.io/acm/leetcode/53maxsum/</link>
      <pubDate>Tue, 31 Aug 2021 17:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/53maxsum/</guid>
      <description>题目链接：53.最大子序和
题目描述 难度 简单 描述 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组[4,-1,2,1] 的和最大，为6 。
示例 2： 输入：nums = [1] 输出：1
示例 3： 输入：nums = [0] 输出：0
示例 4： 输入：nums = [-1] 输出：-1
示例 5： 输入：nums = [-100000] 输出：-100000
提示： 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 105
进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
自行解法 一开始并没有想到合适的解法，于是想到最暴力的方式，获取所有子序和并比较
class Solution { /** * 出所有的子序和之后进行比较 * @param Integer[] $nums * @return Integer */ function maxSubArray($nums) { $maxForI = []; for ($i = 0; $i &amp;lt; count($nums); $i++) { $sumForI = $nums[$i]; $maxForJ = []; $max = max($nums); for ($j = $i + 1; $j &amp;lt; count($nums); $j++) { if ($i == $j) { $sumForI = $nums[$i]; } else { $sumForI += $nums[$j]; } $maxForJ[] = max($maxNum, $sumForI, $max); $maxNum = $sumForI; } if (count($nums) == 1) { $maxForJ = $nums; } $maxForI[$i] = max($maxForJ); } return max($maxForI); } } 这种方式可以通过绝大部分测试用例，但是当$nums增加到一定数量级后会超时</description>
    </item>
    
    <item>
      <title>122. 买卖股票的最佳时机</title>
      <link>https://laurel-he.github.io/acm/leetcode/121buyshares/</link>
      <pubDate>Tue, 31 Aug 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/121buyshares/</guid>
      <description>题目链接：122. 买卖股票的最佳时机
题目描述 难度 简单 描述 给定一个数组 prices ，它的第i 个元素prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
提示： 1 &amp;lt;= prices.length &amp;lt;= 105 0 &amp;lt;= prices[i] &amp;lt;= 104
自行解法 暴力解法 暴力解法虽然可以实现，但当数组超出一定长度时会超时
class Solution { /** * @param Integer[] $prices * @return Integer */ function maxProfit($prices) { $countPri = count($prices); $diff = []; for ($i = 0; $i &amp;lt; $countPri; $i++) { $maxDiff = 0; for ($j = $i + 1; $j &amp;lt; $countPri; $j ++) { if ($prices[$j] - $prices[$i] &amp;gt; $maxDiff) { $maxDiff = ($prices[$j] - $prices[$i]); } } $diff[] = $maxDiff; } return max($diff); } } 动态规划(DP)：</description>
    </item>
    
    <item>
      <title>217.存在重复元素</title>
      <link>https://laurel-he.github.io/acm/leetcode/217repeat/</link>
      <pubDate>Tue, 31 Aug 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/217repeat/</guid>
      <description>题目链接：217.存在重复元素
题目描述 难度 简单 描述 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1: 输入: [1,2,3,1] 输出: true
示例 2: 输入: [1,2,3,4] 输出: false
示例3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
自行解法 直接循环，判断每个元素和剩余的其他元素是否重复，不重复则去除这个元素，继续比较
class Solution { /** * @param Integer[] $nums * @return Boolean */ function containsDuplicate($nums) { $dataCheck = $nums; for ($i = 0; $i &amp;lt; count($nums); $i++) { $check = $nums[$i]; unset($dataCheck[$i]); if (in_array($check, $dataCheck)) { return true; } } return false; } } 其他优质解法 先去重，判断去重后的长度是否比之前的长度短，是则说明有重复</description>
    </item>
    
    <item>
      <title>Leetcode刷题</title>
      <link>https://laurel-he.github.io/post/2019-03-07/</link>
      <pubDate>Fri, 26 Jul 2019 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/2019-03-07/</guid>
      <description>1 两数之和 描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] `</description>
    </item>
    
  </channel>
</rss>
