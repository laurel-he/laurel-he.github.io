<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刷题 on </title>
    <link>https://laurel-he.github.io/categories/%E5%88%B7%E9%A2%98/</link>
    <description>Recent content in 刷题 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 31 Aug 2021 17:10:10 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/categories/%E5%88%B7%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>53. 最大子序和</title>
      <link>https://laurel-he.github.io/acm/leetcode/53maxsum/</link>
      <pubDate>Tue, 31 Aug 2021 17:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/53maxsum/</guid>
      <description>题目链接：53. 最大子序和
题目描述 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6c 解释：连续子数组[4,-1,2,1] 的和最大，为6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [0] 输出：0 示例 4：
输入：nums = [-1] 输出：-1 示例 5：
输入：nums = [-100000] 输出：-100000
提示：
1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 105
进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
自行解法 一开始并没有想到合适的解法，于是想到最暴力的方式，获取所有子序和并比较
class Solution { /** * 出所有的子序和之后进行比较 * @param Integer[] $nums * @return Integer */ function maxSubArray($nums) { $maxForI = []; for ($i = 0; $i &amp;lt; count($nums); $i++) { $sumForI = $nums[$i]; $maxForJ = []; $max = max($nums); for ($j = $i + 1; $j &amp;lt; count($nums); $j++) { if ($i == $j) { $sumForI = $nums[$i]; } else { $sumForI += $nums[$j]; } var_dump([$maxNum, $sumForI]); $maxForJ[] = max($maxNum, $sumForI, $max); $maxNum = $sumForI; } if (count($nums) == 1) { $maxForJ = $nums; } $maxForI[$i] = max($maxForJ); } return max($maxForI); } } 这种方式可以通过绝大部分测试用例，但是当$nums增加到一定数量级后会超时</description>
    </item>
    
    <item>
      <title>217. 存在重复元素</title>
      <link>https://laurel-he.github.io/acm/leetcode/217repeat/</link>
      <pubDate>Tue, 31 Aug 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/217repeat/</guid>
      <description>题目链接：217. 存在重复元素
题目描述 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1:
输入: [1,2,3,1] 输出: true 示例 2:
输入: [1,2,3,4] 输出: false 示例3:
输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
自行解法 直接循环，判断每个元素和剩余的其他元素是否重复，不重复则去除这个元素，继续比较
class Solution { /** * @param Integer[] $nums * @return Boolean */ function containsDuplicate($nums) { $dataCheck = $nums; for ($i = 0; $i &amp;lt; count($nums); $i++) { $check = $nums[$i]; unset($dataCheck[$i]); if (in_array($check, $dataCheck)) { return true; } } return false; } } 其他优质解法 先去重，判断去重后的长度是否比之前的长度短，是则说明有重复</description>
    </item>
    
    <item>
      <title>Leetcode刷题</title>
      <link>https://laurel-he.github.io/post/2019-03-07/</link>
      <pubDate>Fri, 26 Jul 2019 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/2019-03-07/</guid>
      <description>1 两数之和 描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] `</description>
    </item>
    
  </channel>
</rss>
