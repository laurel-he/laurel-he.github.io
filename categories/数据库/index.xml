<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on </title>
    <link>https://laurel-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 02 Apr 2021 18:27:44 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mysql必知必会学习笔记-1-基础概念</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</link>
      <pubDate>Fri, 02 Apr 2021 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</guid>
      <description>概念 定义 数据库 数据库是用来保存有组织的数据的容器
表 某种特定类型数据的结构化清单（在类似mongodb等nosql数据库中，表的类型和字段都不是固定的）
列 表中的一个字段，所有的表都是由一个或多个列组成的
数据类型 所容许的数据类型，每个表列都有 相应的数据类型，它限制或容许改列中存储的数据
行 表中的一个记录
主键 一列（或一组列），其值能够唯一区分表中的每一行 主键建议 （1）不更新主键列中的值 （2）不重用组件列的值 （3）不在主键列中使用可能会更改的值
mysql命令行连接参数 经常使用的参数:
   参数 解释     u 用户名   h host   P 端口号   p 密码    </description>
    </item>
    
    <item>
      <title>mongodb学习记录</title>
      <link>https://laurel-he.github.io/database/mongo/mongocomplex/</link>
      <pubDate>Sun, 20 Oct 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mongo/mongocomplex/</guid>
      <description>参考文档 http://www.mongoing.com/docs/reference/operator/aggregation/interface.html https://www.cnblogs.com/zhoujie/p/mongo1.html https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/tutorial-text-search-in-aggregation.html
mongodb精准匹配 假设有需求如下：数据为多层级的数组，需要精准匹配到某一个层级，并进行更新或新增等操作，如何实现？
实现方式 当Mongodb版本大于3.6.1，实现将会非常简单，因为mongodb3.6.1以上可以直接通过语句来实现精准匹配。 但由于实际场景中版本不支持，当匹配超过一级则会报错：Too many positional (i.e. &amp;lsquo;$&#39;) elements found in path &amp;lsquo;files.$.testConstruct.params.list.$.testRange&amp;rsquo; 当版本大于3.6.1，举例：
db.test_db.update( {&#39;_id&#39;: {$in: [&#39;1242rererwwr&#39;]}, &#39;files.name&#39;: &#39;test1.json&#39;, &#39;files.testConstruct.params.list.type&#39;: &#39;NewData&#39;}, {$set: {&#39;files.$.structuredContent.params.list.$.testRange&#39;: {&#39;enable&#39;: false, &#39;min&#39;: 14, &#39;max&#39;: 90}}, $currentDate: { updatedDatetime: true }}, { multi: true }) 分析： 设置值时，&amp;lsquo;files.$.testConstruct.params.list.$.testRange&amp;rsquo;中的第一个&amp;quot;$&amp;ldquo;将会匹配到name=test1.json的数组，第二个&amp;rdquo;$&amp;ldquo;将会匹配到files.structuredContent.params.list.type=NewData的数组 优点： 使用简单，匹配精确，无需代码判断 缺点： 适用版本有限制，且由于多级匹配需要更多的条件，而实际业务中不一定能取到这些条件（例如知道要更新的key为testRange但是不知道上级查询条件无法匹配到） 如果版本过低，可只匹配第一级，其余的通过代码匹配。 当版本小于3.6.1举例：
&amp;lt;?php public function batchUpdateContents(string $route, array $ids, string $editor, $updateItems, bool $needPublish): bool { $routes = explode(&amp;#39;-&amp;#39;, $route); array_shift($routes); $routes[2] = self::TYPE_LIST[$routes[2]]; $updateRoute = &amp;#39;files.</description>
    </item>
    
    <item>
      <title>Mysql分库分表</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmerge/</link>
      <pubDate>Mon, 08 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmerge/</guid>
      <description>本文参考MySQL：互联网公司常用分库分表方案汇总！
水平分割和垂直分割 把表数据分成多少多少条，叫做水平分割 表的字段很长，把部分大字段分到另外一个表中，叫垂直分割
瓶颈 IO瓶颈 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&amp;gt; 分库和垂直分表。 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&amp;gt; 分库。
CPU瓶颈 第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&amp;gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。 第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&amp;gt; 水平分表。
分库分表 水平分库 概念 以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
示例 假设是电商场景，根据不同的公司，分成不同的表
结果 每个库的结构都一样； 每个库的数据都不一样，没有交集； 所有库的并集是全量数据；
场景 系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
分析 库多了，io和cpu的压力自然可以成倍缓解。
水平分表 概念 以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
示例 假设数据库中存在一个字段：学号:stu_num，可以按照尾号为0-9分成9个库
结果 每个表的结构都一样； 每个表的数据都不一样，没有交集； 所有表的并集是全量数据；
场景 系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。
分析 表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。
垂直分库 概念 以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
示例 电商包括订单，用户，物流等模块，前期都放在同一个库里，后期不同的模块使用不同的库
结果 每个库的结构都不一样； 每个库的数据也不一样，没有交集； 所有库的并集是全量数据；
场景 系统绝对并发量上来了，并且可以抽象出单独的业务模块。
分析 到这一步，基本上就可以服务化了。 例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。 再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。
垂直分表 概念 以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。
结果 每个表的结构都不一样； 每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据； 所有表的并集是全量数据；</description>
    </item>
    
    <item>
      <title>mongodb使用</title>
      <link>https://laurel-he.github.io/database/mongo/mongo1/</link>
      <pubDate>Tue, 02 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mongo/mongo1/</guid>
      <description>基础  列出所有数据库:show dbs; 列出所有表：show tables;或show collections; 查询所有数据：db.taname.find().pretty(); 查询指定列所有数据：db.tbname.find({},{col1:1,col2:2,&amp;hellip;}).pretty(); 根据条件查询所有数据：db.tbname.find({name:&amp;ldquo;test&amp;rdquo;},{col1:1,col2:1}).pretty(); 查询结果不包含指定字段：db.tbname.find({},{status:0,col2:0}).pretty();  查询 1 查询所有数据 db.tbname.find().pretty();</description>
    </item>
    
    <item>
      <title>mysql索引优化</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlindex/</link>
      <pubDate>Tue, 02 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlindex/</guid>
      <description>1 查看查询语句执行效率 语法 explain select … from … [where &amp;hellip;] 示例
explain select * from news; 只查询一行数据： 查询多行数据：执行查询 执行explain: 2 属性详解    属性 作用     id SELECT的查询序列号   select_type SELECT的查询序列号   table 显示这一行的数据是关于哪张表的   type 显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一   possible_keys 指出MySQL能使用哪个索引在该表中找到行   key 显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL   key_len 显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好   ref 显示使用哪个列或常数与key一起从表中选择行   rows 显示MySQL认为它执行查询时必须检查的行数   Extra 包含MySQL解决查询的详细信息，也是关键参考项之一   select_type        类型 解释     SIMPLE 简单SELECT(不使用UNION或子查询等)   PRIMARY 最外面的SELECT   UNION UNION中的第二个或后面的SELECT语句   DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询   UNION RESULT UNION的结果   SUBQUERY 子查询中的第一个SELECT   DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询   DERIVED 导出表的SELECT(FROM子句的子查询)   type     索引从好到坏依次是：</description>
    </item>
    
    <item>
      <title>mysql数据库维护</title>
      <link>https://laurel-he.github.io/database/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</link>
      <pubDate>Thu, 28 Mar 2019 14:03:27 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Hbase基础命令</title>
      <link>https://laurel-he.github.io/learn/hbase_01/</link>
      <pubDate>Thu, 28 Feb 2019 11:03:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/learn/hbase_01/</guid>
      <description>Hbase基础命令 启动和停止Hbase 启动 hbase/bin ./start-hbase.sh 关闭 hbase/bin ./stop-hbase.sh
使用Hbase 连接Hbase bin/hbase shell 创建表 create &amp;lsquo;test&amp;rsquo; （创建表需要添加列簇） create &amp;lsquo;表名&amp;rsquo; &amp;lsquo;列簇名1&amp;rsquo; &amp;lsquo;列簇名2&amp;rsquo; …… 添加数据 put &amp;lsquo;表名&amp;rsquo; &amp;lsquo;行名&amp;rsquo; &amp;lsquo;列簇名称&amp;rsquo; &amp;lsquo;value&amp;rsquo;（当列簇只有一列） put &amp;lsquo;表名&amp;rsquo; &amp;lsquo;行名&amp;rsquo; &amp;lsquo;列簇名称：列名称&amp;rsquo; &amp;lsquo;value&amp;rsquo; 查看表 list: 查看所有表 list &amp;lsquo;tablename&amp;rsquo; ： 查看表名为tablename的表 删除表 disable &amp;lsquo;表名&amp;rsquo;(对应enable &amp;lsquo;明白&amp;rsquo;) drop &amp;lsquo;表名&amp;rsquo;
配置 ####基础配置 conf/hbase-site.xml
注意事项 （1）表名，行，列都必须用引号括起来 {% plantuml %} {% endplantuml %}</description>
    </item>
    
  </channel>
</rss>
