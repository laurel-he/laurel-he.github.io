<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on </title>
    <link>https://laurel-he.github.io/categories/mysql/</link>
    <description>Recent content in mysql on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 08 Apr 2019 18:27:44 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/categories/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mysql分库分表</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmerge/</link>
      <pubDate>Mon, 08 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmerge/</guid>
      <description>本文参考MySQL：互联网公司常用分库分表方案汇总！
水平分割和垂直分割 把表数据分成多少多少条，叫做水平分割 表的字段很长，把部分大字段分到另外一个表中，叫垂直分割
瓶颈 IO瓶颈 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&amp;gt; 分库和垂直分表。 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&amp;gt; 分库。
CPU瓶颈 第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&amp;gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。 第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&amp;gt; 水平分表。
分库分表 水平分库 概念 以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
示例 假设是电商场景，根据不同的公司，分成不同的表
结果 每个库的结构都一样； 每个库的数据都不一样，没有交集； 所有库的并集是全量数据；
场景 系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
分析 库多了，io和cpu的压力自然可以成倍缓解。
水平分表 概念 以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
示例 假设数据库中存在一个字段：学号:stu_num，可以按照尾号为0-9分成9个库
结果 每个表的结构都一样； 每个表的数据都不一样，没有交集； 所有表的并集是全量数据；
场景 系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。
分析 表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。
垂直分库 概念 以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
示例 电商包括订单，用户，物流等模块，前期都放在同一个库里，后期不同的模块使用不同的库
结果 每个库的结构都不一样； 每个库的数据也不一样，没有交集； 所有库的并集是全量数据；
场景 系统绝对并发量上来了，并且可以抽象出单独的业务模块。
分析 到这一步，基本上就可以服务化了。 例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。 再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。
垂直分表 概念 以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。
结果 每个表的结构都不一样； 每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据； 所有表的并集是全量数据；</description>
    </item>
    
    <item>
      <title>mysql必知必会学习笔记-2-检索数据</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmustknown_02/</link>
      <pubDate>Wed, 03 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmustknown_02/</guid>
      <description>select语句 -- 简单的查询 select prod_name from ta_name; -- 查询几个列 select prod_id, prod_name from tb_name; -- 查询所有列，一般不建议，检索不需要的列通常会降低检索和应用程序的性能 select * from tb_name; -- 只返回不同的值 select distinct xxx_id from tb_name; -- 返回前5行 select prod_name from tb_name limit 5; -- 限制开始行和行数，例如从第3行开始，返回5行 select prod_name from tb_name limit 3,5; -- 从Mysql5开始，从第3行返回5行可以写作： select prod_mame from tb_name limit 5 OFFSET 3; 注意事项 （1）在原书中有这么一段话：
 不能部分使用DISTINCT。DISTINCT关键字应用于所有列而 不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被 检索出来
 我自己建表试过，翻译一下就是，一般来说DISTINCT用于单列的去重，当用于多列的时候，当这两个列的值完全一样时会被去重，当其中一个值或者以上不同时，不会被去重。
（2）第一行是行0, limit 1,1实际上返回的是第2行数据。带一个值的返回的是第0行，也就是人眼看到的第一行的数据。
排序检索数据 关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。
示例：</description>
    </item>
    
    <item>
      <title>mysql必知必会学习笔记-1-基础概念</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</link>
      <pubDate>Tue, 02 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</guid>
      <description>基础复习 本书大概通读了一遍，内容几乎都是我知道或者学过的，但是我依然想再详细阅读一遍，并且跟着书中的示例来实际操作下，打牢基础。以下是学习笔记。
概念 定义 数据库 数据库是用来保存有组织的数据的容器
表 某种特定类型数据的结构化清单（在类似mongodb等nosql数据库中，表的类型和字段都不是固定的）
列 表中的一个字段，所有的表都是由一个或多个列组成的
数据类型 所容许的数据类型，每个表列都有相应的数据类型，它限制或容许改列中存储的数据
行 表中的一条记录
主键 一列（或一组列），其值能够唯一区分表中的每一行 主键建议 （1）不更新主键列中的值 （2）不重用组件列的值 （3）不在主键列中使用可能会更改的值
模式 关于数据库和表的布局及特性的信息。
分类 DBMS分为两种，一类为基于共享文件系统的DBMS，另一类为基于客户机—服务器的DBMS。
客户机-服务器 与数据文件打交道的只有服务器软件。关于数据、数据添加、删除 和数据更新的所有请求都由服务器软件完成。这些请求或更改来自运行 客户机软件的计算机。客户机是与用户打交道的软件。例如，如果你请 求一个按字母顺序列出的产品表，则客户机软件通过网络提交该请求给 服务器软件。服务器软件处理这个请求，根据需要过滤、丢弃和排序数 据；然后把结果送回到你的客户机软件。
使用 mysql命令行连接参数 经常使用的参数:
   参数 解释     u 用户名   h host   P 端口号   p 密码    一些基础命令 -- 选择数据库 use db_name; -- 查看所有数据库 show databases; -- 查看所有表 SHOW TABLES; -- 显示表列 SHOW COLUMNS FROM tb_name; desc tb_name; describe tb_name; -- 显示广泛的服务器状态信息 SHOW STATUS; -- 显示创建数据库的信息 show create database db_name; -- 显示创建表的信息 show create table tb_name; -- 显示授权用户的安全权限 SHOW GRANTS; -- 显示服务器错误或警告信息 show errors; show warnings; -- 显示允许使用的show语句 help show; </description>
    </item>
    
    <item>
      <title>mysql索引优化</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlindex/</link>
      <pubDate>Tue, 02 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlindex/</guid>
      <description>1 查看查询语句执行效率 语法 explain select … from … [where &amp;hellip;] 示例
explain select * from news; 只查询一行数据： 查询多行数据：执行查询 执行explain: 2 属性详解    属性 作用     id SELECT的查询序列号   select_type SELECT的查询序列号   table 显示这一行的数据是关于哪张表的   type 显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一   possible_keys 指出MySQL能使用哪个索引在该表中找到行   key 显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL   key_len 显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好   ref 显示使用哪个列或常数与key一起从表中选择行   rows 显示MySQL认为它执行查询时必须检查的行数   Extra 包含MySQL解决查询的详细信息，也是关键参考项之一   select_type        类型 解释     SIMPLE 简单SELECT(不使用UNION或子查询等)   PRIMARY 最外面的SELECT   UNION UNION中的第二个或后面的SELECT语句   DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询   UNION RESULT UNION的结果   SUBQUERY 子查询中的第一个SELECT   DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询   DERIVED 导出表的SELECT(FROM子句的子查询)   type     索引从好到坏依次是：</description>
    </item>
    
    <item>
      <title>mysql数据库维护</title>
      <link>https://laurel-he.github.io/database/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</link>
      <pubDate>Thu, 28 Mar 2019 14:03:27 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
