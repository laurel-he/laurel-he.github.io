<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on </title>
    <link>https://laurel-he.github.io/tags/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 20 Jul 2021 16:34:10 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/tags/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>操作系统（1）-基础和vim操作</title>
      <link>https://laurel-he.github.io/post/opratingsystem_01/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/opratingsystem_01/</guid>
      <description>本系列来源于蓝桥：https://www.lanqiao.cn/courses/2610 同系列文已发布在CSDN
命令行中的shell通配符    字符 含义     * 匹配0或多个字符   ? 匹配任意一个字符   [list] 匹配 list 中的任意单一字符   [^list] 匹配 除list 中的任意单一字符以外的字符   [c1-c2] 匹配 c1-c2之间的任意单一字符   {string1, string2&amp;hellip;} 匹配 string1 或 string2 (或更多)其一字符串   {c1..c2} 匹配 c1-c2 中全部字符 如{1..10}    示例 创建用户lilei sudo adduser lilei
将lilei加入sudo组 sudo usermod -G sudo lilei
删除用户lilei sudo deluser lilei &amp;ndash;remove-home</description>
    </item>
    
    <item>
      <title>操作系统（2）-进程管理</title>
      <link>https://laurel-he.github.io/post/opratingsystem_02/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/opratingsystem_02/</guid>
      <description>蓝桥操作系统课程的学习笔记
top 实时查看进程的状态 top第一行
   内容 解释     top 表示当前程序的名称   14:11:28 当前系统的时间   up 231 days, 20:31 表示改机器已经启动了多长时间   1 user 表示当前系统只有一个用户   load average: 0.24, 0.32, 0.19 分别对应1、5、15分钟内cpu的平均负载   top第二行    内容 解释   &amp;ndash; &amp;ndash;   Tasks: 26 toal 进程总数   1 running 1个正在运行的进程   25 sleeping 25个正在睡眠的进程数   0 stopped 没有停止的进程数   0 zombie 没有僵尸进程数   top第三行    基本是cpu使用情况的统计    内容 解释   &amp;ndash; &amp;ndash;   Cpu(s):1.</description>
    </item>
    
    <item>
      <title>操作系统（3）</title>
      <link>https://laurel-he.github.io/post/opratingsystem_03/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/opratingsystem_03/</guid>
      <description>Linux实现模拟多进程并发执行 示例：
#!/bin/bash for((i=0;i&amp;lt;5;i++)) do { sleep 1; echo &amp;#34;$i--&amp;#34;&amp;gt;&amp;gt;aa &amp;amp;&amp;amp; echo &amp;#34;done&amp;#34; }&amp;amp; done wait cat aa | wc -l rm aa 解析 &amp;amp;代表并发执行，wait等待前面执行完了再执行，例如此示例中，如果没有wait很可能还没创建aa文件
Linux下的中断 #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; int main(void) { pid_t pid; //pid  printf(&amp;#34;Before fork... &amp;#34;); switch( pid = fork()) { case -1: printf(&amp;#34;fork call fail &amp;#34;); fflush(stdout); exit(1); case 0: printf(&amp;#34;child call &amp;#34;); printf(&amp;#34;the pid of child is %d &amp;#34;, getpid()); printf(&amp;#34;the pid of child&amp;#39;s parent is %d &amp;#34;, getppid()); printf(&amp;#34;child exiting.</description>
    </item>
    
    <item>
      <title>数据结构学习笔记-1</title>
      <link>https://laurel-he.github.io/post/datastruct_01/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/datastruct_01/</guid>
      <description>数据结构学习系列都来自于中国大学MOOC上的浙江大学数据结构学习课程。原课程代码全部采用C语言实现，由于本菜平时最擅长（zhihuiyong）使用php，因此所有算法全部翻译成了php实现。课程链接：数据结构 全文已同步发布到CSDN
定义 （1）数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义和相关的函数来给出 （2）数据结构是ADT(abstruct data type)的物理实现 （3）数据结构是计算机存储，组织数据的方式，通常情况下，精心选择的数据结构可以带来最有效率的算法
示例 写程序实现一个函数printN，打印从1-N之间的所有正整数 。以下是两种实现方式的php实现代码：
&amp;lt;?php function printN($n) { $i = 0; for($i = 0; $i &amp;lt; $n; $i++) { echo $i. &amp;#34;\n\r&amp;#34;; } } $begin1 = microtime(); printN(10000); $end1 = microtime(); $time1 = $end1 - $begin1; function printM($m) { if ($m) { printM($m - 1); echo $m. &amp;#34;\n\r&amp;#34;; } } $begin2 = microtime(); printM(10000); $end2 = microtime(); $time2 = $end2 - $begin2; echo $time2 - $time1; 递归和直接循环打印都可以实现，但是递归当数字大于1w左右就失败了，因为递归对空间的占用十分恐怖。解决问题方法的效率，也与空间的占用效率是有关的。</description>
    </item>
    
    <item>
      <title>mysql必知必会学习笔记-1-基础概念</title>
      <link>https://laurel-he.github.io/post/mysqlmustknown_01/</link>
      <pubDate>Fri, 02 Apr 2021 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/mysqlmustknown_01/</guid>
      <description>概念 定义 数据库 数据库是用来保存有组织的数据的容器
表 某种特定类型数据的结构化清单（在类似mongodb等nosql数据库中，表的类型和字段都不是固定的）
列 表中的一个字段，所有的表都是由一个或多个列组成的
数据类型 所容许的数据类型，每个表列都有 相应的数据类型，它限制或容许改列中存储的数据
行 表中的一个记录
主键 一列（或一组列），其值能够唯一区分表中的每一行 主键建议 （1）不更新主键列中的值 （2）不重用组件列的值 （3）不在主键列中使用可能会更改的值
mysql命令行连接参数 经常使用的参数:
   参数 解释     u 用户名   h host   P 端口号   p 密码    </description>
    </item>
    
    <item>
      <title>kustomize使用文档</title>
      <link>https://laurel-he.github.io/post/kustomize01/</link>
      <pubDate>Thu, 21 May 2020 11:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/kustomize01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>kubenetes权威指南1-2章</title>
      <link>https://laurel-he.github.io/post/k8s01/</link>
      <pubDate>Sat, 16 May 2020 18:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/k8s01/</guid>
      <description>kubenetes是什么 k8s是一个全新的基于容器技术的分布式架构领先方案，一个开放的开发平台，一个完备的分布式系统支撑平台
k8s重要资源对象介绍 Master 概念介绍 k8s中的Master指的是集群控制节点，在每个集群里都需要有一个Master来负责整个集群的管理和控制。
关键进程 （1）Kubenetes API Server(kube-apiserver):提供了HTTP Rest接口的额关键服务进程，是 kubenetes里所有资源的增删改查等操作的唯一入口，也是集群控制的入口进程 （2）kubenetes Controller Manager(kube-controller-manager):kubenetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的大总管 （3）Kubenetes Scheduler(kube-scheduler):负责资源调度(Pod调度)的进程，相当于哦公交公司的调度室
Node 概念介绍 除了Master,Kubenetes集群中的其他机器被称为Node。Node是集群中的工作负载节点，每个Node都会被Master分配一些工作负载(Docker容器)，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上
关键进程 （1）kubelet:负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，，实现集群管理的基本功能 （2）kube-proxy:实现kubenetes Service的通信与负载均衡的重要组件 （3）Docker Engine：负责本机的容器的创建和管理工作
Pod 概念介绍 在Kubernetes中，最小的管理元素不是一个个独立的容器，而是Pod,Pod是最小的，管理，创建，计划的最小单元.
部分概念 （1）可以设置限额的计算资源有CPU和Memory两种： 通常以千分之一的CPU配额为最小单位，用m来表示 Memory配额也是一个绝对值，单位是内存字节数 （2）Event是一个事件的记录，记录了事件的最早产生事件，最后重现事件，重复次数，发起者，类型，以及导致此事件的原因等众多信息。
Label 概念 一个Label是一个key=value的键值对,可类似于sql查询语句一样来进行查询
Deployment Deployment内部使用了Replica Set来实现目的
kubectl的create命令和apply命令的区别 kubectl create：
（1）kubectl create命令，是先删除所有现有的东西，重新根据yaml文件生成新的。所以要求yaml文件中的配置必须是完整的
（2）kubectl create命令，用同一个yaml 文件执行替换replace命令，将会不成功，fail掉。
kubectl apply：
 kubectl apply命令，根据配置文件里面列出来的内容，升级现有的。所以yaml文件的内容可以只写需要升级的属性</description>
    </item>
    
    <item>
      <title>设计模式从头学习-面向对象设计原则概述</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/design_pattern02/</link>
      <pubDate>Thu, 07 May 2020 20:20:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/design_pattern02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>设计模式从头学习-前言</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/design_patter01/</link>
      <pubDate>Thu, 07 May 2020 20:13:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/design_patter01/</guid>
      <description>注意 本文参考了书籍《大话设计模式》和文章从招式与内功谈起——设计模式概述 #写作初衷 我有空的时候就会学习一下设计模式，零零散散半年过去了，真正能够静下心来学习 设计模式的事件少之又少，而且很多模式例如单例模式，命令模式等我学过后就忘了，让我现在再 复述或者使用我又需要重新去学一下，因此我抛弃以前学习的零零散散的与设计模式相关的东西， 尝试从头再学一次，边学边使用，并做好详细的笔记，以后可以直接翻阅。 #设计模式的作用 (1)设计模式经过多年的使用和实践，包含了大量成功的，可维护可复用的设计方案，在很多情况下，设计模式可以提高开发效率，节约时间 (2)设计模式跨语言、跨平台、跨应用、跨国界，提供了通用的词汇和使用方式，节约交流时间 (3)大部分设计模式都兼顾了系统的可重用性和扩展性，这使很多系统可以重用，减少代码重复 (4)合理使用设计模式有助于别人理解自己的代码 (5)有助于更为深刻地理解面对对象编程 #如何掌握设计模式 a.这个设计模式的意图是什么 b.它要解决一个什么问题 c.什么时候可以使用它 d.它是如何解决问题的 e.掌握它的结构图 f.记住它的关键代码 g.能够想到至少两个它的应用实例，一个生活中的，一个软件中的 h.这个模式的优缺点是什么 i.在使用时要注意什么 #注意事项 （1）最好的掌握设计模式的方法是使用它们 （2）千万不要滥用模式</description>
    </item>
    
    <item>
      <title>《第一本docker书》学习笔记01</title>
      <link>https://laurel-he.github.io/post/docker01/</link>
      <pubDate>Tue, 21 Apr 2020 21:03:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/docker01/</guid>
      <description>Docker与配置管理 docker的核心组件 （1）docker客户端和服务器，也称为docker引擎 （2）docker镜像 （3）Registry （4）Docker容器
基本使用 docker info 查看docker程序是否存在，功能是否正常
docker exec(docker run) docker run 命令提供了docker容器的创建到启动的功能 (1)-i:保证容器STDIN是开启的 (2)-t:为要撞见的容器分配一个伪tty终端 docker exec -it backend_jiapin /bi n/bash</description>
    </item>
    
    <item>
      <title>linux命令大全</title>
      <link>https://laurel-he.github.io/post/linuxope/</link>
      <pubDate>Thu, 27 Feb 2020 18:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/linuxope/</guid>
      <description>系统信息 arch 描述
显示机器的处理器架构 举例
uname 描述
显示机器的处理器架构 参数
-a或&amp;ndash;all 显示全部的信息。 -m或&amp;ndash;machine 显示电脑类型。 -n或-nodename 显示在网络上的主机名称。 -r或&amp;ndash;release 显示操作系统的发行编号。 -s或&amp;ndash;sysname 显示操作系统名称。 -v 显示操作系统的版本。 &amp;ndash;help 显示帮助。 &amp;ndash;version 显示版本信息。 举例
dmidecode 描述
显示硬件信息，不常用，可忽略
开关机 shutdown 描述
关机或重启 参数
-t seconds : 设定在几秒钟之后进行关机程序。 -k : 并不会真的关机，只是将警告讯息传送给所有使用者。 -r : 关机后重新开机。 -h : 关机后停机。 -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。 -c : 取消目前已经进行中的关机动作。 -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。 -F : 关机时，强迫进行 fsck 动作。 time : 设定关机的时间。 message : 传送给所有使用者的警告讯息。</description>
    </item>
    
    <item>
      <title>linux命令大全</title>
      <link>https://laurel-he.github.io/post/linuxuse/</link>
      <pubDate>Thu, 27 Feb 2020 18:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/linuxuse/</guid>
      <description>文件操作 cat 描述
查看文件内容 参数
-n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting 举例 1 从键盘创建一个文件： 2 将几个文件合并成一个文件： cd 描述</description>
    </item>
    
    <item>
      <title>计算相关</title>
      <link>https://laurel-he.github.io/post/codecollect/</link>
      <pubDate>Tue, 25 Feb 2020 20:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/codecollect/</guid>
      <description>1 计算矩形是否相交 描述 给定两个矩形的左上角起始点坐标和矩形的宽，高，计算这两个矩形是否相交 分析 1 矩形1左上角坐标p1,右下角坐标p2,矩形2左上角坐标p3,右下角坐标p4 2 M点坐标为P1与P3点在X方向较大值与Y方向较大值的交点 3 N点坐标为P2与P4点在X方向较小值与Y方向较小值的交点 4 如果M点的X坐标和Y坐标值均比N点相应的X坐标和Y坐标值小，亦即M和N可以分别构成一个矩形的左上角点和右上角点，则两矩形相交；其余情况则不相交 代码
&amp;lt;?php function checkRectInterSect($rect1, $rect2) { $x1 = $rect1[&amp;#39;x&amp;#39;]; $w1 = $rect1[&amp;#39;w&amp;#39;]; $y1 = $rect1[&amp;#39;y&amp;#39;]; $h1 = $rect1[&amp;#39;h&amp;#39;]; $x2 = $rect2[&amp;#39;x&amp;#39;]; $w2 = $rect2[&amp;#39;w&amp;#39;]; $y2 = $rect2[&amp;#39;y&amp;#39;]; $h2 = $rect2[&amp;#39;h&amp;#39;]; $p1 = [$x1, $y1]; $p2 = [$x1 + $w1, $y1 + $h1]; $p3 = [$x2, $y2]; $p4 = [$x2 + $w2, $y2 + $h2]; $M = [max($p1[0], $p3[0]), max($p1[1], $p1[1])]; $N = [min($p2[0], $p4[0]), min($p2[1], $p4[1])]; if ($M[0] &amp;lt; $N[0] &amp;amp;&amp;amp; $M[1] &amp;lt; $N[1]) { return true; } else { return false; } } ?</description>
    </item>
    
    <item>
      <title>运行相关</title>
      <link>https://laurel-he.github.io/post/codecollect2/</link>
      <pubDate>Tue, 25 Feb 2020 20:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/codecollect2/</guid>
      <description>1 下载数据 描述 根据链接下载文件 代码
&amp;lt;?php function downloadOldFile($url,$rename,$ext){ $file_path = &amp;#39;public/images/age_60-120/&amp;#39;; $ch = curl_init($url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_BINARYTRANSFER, 1); $rawdata=curl_exec ($ch); curl_close ($ch); // 使用中文文件名需要转码  $fp = fopen($file_path. $rename .&amp;#34;.&amp;#34;.$ext,&amp;#39;w&amp;#39;); fwrite($fp, $rawdata); fclose($fp); // 返回路径  return $_SERVER[&amp;#39;DOCUMENT_ROOT&amp;#39;].$file_path.$rename.&amp;#34;.&amp;#34;.$ext; } ?&amp;gt;2 按步骤执行方法 描述 经常有需求：分页执行脚本，例如前1000条执行完后继续分页，此时就需要自动跳页执行 代码
&amp;lt;?php /** * @param mixed ...$args * @return bool * @throws Exception */ private function stepRun(...$args) { $count = $args[0]; $method = $args[1]; $step = array_key_exists(2, $args) ?</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/design_singleton/</link>
      <pubDate>Tue, 29 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/design_singleton/</guid>
      <description>概念介绍 情景介绍 一个类只需要被实例化一次，但是不应该由调用方来判断是否被实例化过
基础介绍 所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。 类把构造方法设置为私有，使所有的方法都不能直接实例化这个类。然后类内部写一个公共方法来判断这个类是否被实例化过，调用方无需判断
单例模式 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 通常可以让一个全局变量使得一个对象被访问，但它不能防止实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</description>
    </item>
    
    <item>
      <title>代码整洁之道1-9章</title>
      <link>https://laurel-he.github.io/post/cleancode/</link>
      <pubDate>Mon, 07 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/cleancode/</guid>
      <description>提要 要有代码：代码呈现了需求的细节，将需求明确到机器可以执行的细节程度 不要产生糟糕的、混乱的代码，勒布朗法则：稍后等于永不 制造混乱无益于赶上期限，做得快的唯一方法就是始终保持代码整洁。
好代码的特点 优雅、搞笑；代码逻辑直截了当，缺陷难以隐藏； 尽量减少依赖关系，使之便于维护； 根据某种分层战略完善处理错误代码，性能调至最优 整洁的代码力求集中，每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染 整洁的代码可由作者之外的开发者阅读和增补，它应当有单元测试和验收测试 尽量使用有意义的命名，它只提供一种而非多种做一件事的途径 尽量少的依赖关系，明确地定义和提供清晰、尽量少的API
总结 （1）能通过所有测试 （2）没有重复代码 （3）体现系统中的全部设计理念 （4）包含尽量少的实体，比如类、方法、函数等 不要重复代码，只做一件事，表达力，小规模抽象
有意义的命名 （1）如果名称需要注释来补充，那就不算是名副其实（之前出现过争议） （2）不要使用意义含糊的废话，如果名称相同但是意义不同，那么info和data与a an the一样毫无意义，不要使用废话，varable不应出现在便能两种，table不应出现在表中 （3）使用读得出来的名称，方便阅读 （4）使用方便搜索的名称 （5）避免使用编码 （6）应当把类和函数做得足够小，消除对成员前缀的需要，读代码的人通常不会读前缀 （7）不要在类名中使用奇怪的命名 （8）不要使用双关语
函数 （1）函数应该尽可能小，20行封顶最佳 （2）每个函数都一目了然，每个函数都只说一件事，每个函数都依次带到下一个函数 （3）函数的缩进层不应该多余一层或两层
需要遵循的原则 （1）确保每隔switch函数都埋藏在较低的抽象层而且永远不重复 （2）不要向函数传入布尔值（我以前经常这么做），因为传入布尔值表示函数会有多余的操作 （3）使用异常代替返回错误码（错误代码能从主路径代码中分离出来得到简化） （4）抽离try/catch代码块 （5）不要重复自己
注释 注意 注释存在的时间越久，就离它所描述的代码越远，越来越变得全然错误，因为程序员不能坚持维护注释
必要的注释（好的注释） （1）法律信息 （2）提供信息的注释 （3）对意图的解释 （4）阐释（如果参数或返回值是某个标准库的一部分或者不能修改的代码，帮助阐释其含义的代码就会有用） （5）警示
单元测试 </description>
    </item>
    
    <item>
      <title>设计模式六大原则</title>
      <link>https://laurel-he.github.io/designpattern/others/codeprinceple/</link>
      <pubDate>Mon, 07 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/others/codeprinceple/</guid>
      <description>本文参考了设计模式六大原则
单一职责原则（SPR:Single Responsibility Principle） 一个类应该有且仅有一个原因导致该类的变更，即一个类应该只负责一项职责 但是在实际工作中，职责是会扩散的，一个类可能会新增更多的职责， 只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则
遵循单一职责原的优点： （1）可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； （2）提高类的可读性，提高系统的可维护性； （3）变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。
第二：里氏替换原则（LSP:Liskcov Substitution Principle） 定义 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 可以简单的理解为子类型能够替换它们的基类型
含义解析 （1）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 （2）子类中可以增加自己特有的方法。 （3）当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 （4）当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格
违反里氏替换原则的危害 （1）反直觉。期望所有子类行为是一致的，但如果不一致可能需要文档记录，或者在代码跑失败后涨此知识； （2）不可读。如果子类行为不一致，可能需要不同的逻辑分支来适配不同的行为，徒增代码复杂度； （3）不可用。可能出错的地方终将会出错。 如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替
第三：依赖倒置原则（DIP:Dependence Inversion Principle） 定义 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象 针对接口编程，不要针对实现编程
解释 依赖倒置原则基于这样一个事实： 相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。 在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。
示例 /** * 高层类Library需要实现readContent，但是readContent针对不同 * 类有不同的表现形式，于是抽象出来，这样不管怎么扩展修改，Library不用改 **/ class DesignController { /** *yii design/run */ public function actionRun() { $user = new User(); $data = $user-&amp;gt;gotoLibrary(); var_dump($data); } } class User { public function gotoLibrary() { $book = (new Library())-&amp;gt;read(new Book()); $news = (new Library())-&amp;gt;read(new Newspaper()); return [$book, $news]; } } class Library { public function read(IReader $reader) { return $reader-&amp;gt;readContent(); } } interface IReader { /** * 读取内容 * @return mixed */ public function readContent(); } class Book implements IReader { public function readContent() { return &amp;#39;书籍：小王子&amp;#39;; } } class Newspaper implements IReader { public function readContent() { return &amp;#39;报纸：今天奥运会结束了&amp;#39;; } } 第四：接口隔离原则(ISP:Interface Segregation Principle) 定义 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/singlemode/</link>
      <pubDate>Sun, 06 Oct 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/singlemode/</guid>
      <description>基础介绍 概念介绍 作为对象的创建模式，单例模式确保某一个类只有一个实例，并且对外提供这个全局实例的访问入口。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。
单例模式三要素  需要一个保存类的唯一实例的静态成员变量。 构造函数和克隆函数必须声明为私有的，防止外部程序创建或复制实例副本。 必须提供一个访问这个实例的公共静态方法，从而返回唯一实例的一个引用。  </description>
    </item>
    
    <item>
      <title>工作经验总结</title>
      <link>https://laurel-he.github.io/post/work/</link>
      <pubDate>Sat, 05 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/work/</guid>
      <description>工作经验 （1）学会控制情绪</description>
    </item>
    
    <item>
      <title>代码大全</title>
      <link>https://laurel-he.github.io/post/codecomplate_01/</link>
      <pubDate>Sat, 05 Oct 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/codecomplate_01/</guid>
      <description>前期准备 前期准备的重要性 不要立即开始写代码，要做好必要的需求分析和架构设计，写好需求文档和技术文档，防止浪费时间和精力制造错误的东西
需求核对表 针对功能需求：
1．是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？
2．是否详细定义了系统的全部输出，包括其目的地、精度、取值范围、出现频率格式等？
3．是否详细定义了所有的输出格式(如：web页面、报表等)？
4．是否详细定义了所有硬件及软件的外部接口？
5．是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等？
6．是否列出了用户所要做的全部事情？
7．是否详细定义了每个任务所用数据，以及每个任务得到的数据
针对非功能需求（质量需求）
1.是否为全部必要的操作，从用户的角度，详细描述的期望的响应时间 ？
2.是否详细描述了其他与计时有关的考虑，如处理时间、数据传输率、系统吞吐量等？
3.是否详细定义了安全级别
4.是否详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检查与回复的策略等？
5.是否详细定义了机器内存和剩余硬盘空间最小值？
6.是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件接口变更的能力？
7.是否包含对“成功”的定义，“失败”的定义？
需求的质量
  需求是用户书写的吗？
  每条需求都不与其他需求冲突吗？
  是否详细定义了相互竞争的特性之间的权衡
  是否避免在需求中规定设计(方案)
  需求是否在详细程度上保持相当一致的水平？有些需求应当更详细的描述吗？有些需求应该更粗略的描述吗？
  需求是否足够清晰，即使转交给一个独立的小组去构建，他们也能理解吗？开发者也这么想吗？
  每个条款都与待解决的问题及解决方案相关吗？能从每个条款上溯到它的问题中的对应跟源吗？
  是否每条需求都是可测试的？是否可应进行独立的测试，以检验满不满足各项需求
  是否描述了所有可能对需求的改动，包括各项改动的可能性
  需求的完备性
1.对于在开始开发之前无法获得信息，是否详细描述了信息不完全的区域？
2.需求的完备度是否达到这种程度：如果产品满足所有需求，那么它就是可接受的？
3.你对全部需求都感觉舒服吗？你是否已经去掉了那些不可能完成的需求—那些只是为了安抚客户和老板的东西？
花费在前期准备上的时间长度 花费在问题定义，需求分析，软件架构上的时间依据项目的需要而变化，一般占据10%-20%的工作量和20%-30%的时间
良好的类接口 类的基础是抽象数据类型（我之前大部分时候没有使用抽象，只是把相关的方法和变量定义放在了一起，实际上是不符合面向对象变成原则的），抽象数据类型是指一些数据和 对这些数据所进行操作的集合。定义抽象类有助于代码规范，提高
创建类的原因 （1）为显示世界中的对象建模 （2）为抽象的对象建模 （3）降低复杂度 （4）隔离复杂度 （5）隐藏实现细节 （6）让代码更易重用 （7）把相关的操作包装到一起
应当避免的类 （1）避免创建万能类 （2）消除无关紧要的类 （3）避免用动词命名的类</description>
    </item>
    
    <item>
      <title>react单元测试</title>
      <link>https://laurel-he.github.io/post/reactunit/</link>
      <pubDate>Mon, 29 Jul 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/reactunit/</guid>
      <description>测试 ESLint 代码检查（分析JavaScript代码）,JSHint和JSLint是用于分析JavaScript代码的原生工具，并且可以为用户提供格式化代码的反馈意见；</description>
    </item>
    
    <item>
      <title>Leetcode刷题</title>
      <link>https://laurel-he.github.io/post/2019-03-07/</link>
      <pubDate>Fri, 26 Jul 2019 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/2019-03-07/</guid>
      <description>1 两数之和 描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] `</description>
    </item>
    
    <item>
      <title>python100例学习笔记</title>
      <link>https://laurel-he.github.io/post/20190202/</link>
      <pubDate>Sat, 02 Feb 2019 13:25:21 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/20190202/</guid>
      <description>四个数组成不重复三位数 描述 有四个数字，1,2,3,4，能组成多少个不重复的三位数 思考 原文分析：将所有的数字排列组合后去掉不满足条件的列 代码
num = 1; for i in range(1,5): for j in range(1,5): for k in range(1,5): if(i != k) and (i != j) and (j != k): print i,j,k num = num + 1 print num 扩展 循环三次效率很低，每次循环都是1-5，有没有更好的解决办法
2 </description>
    </item>
    
    <item>
      <title>各种奇怪的坑</title>
      <link>https://laurel-he.github.io/post/2019_01_01/</link>
      <pubDate>Fri, 01 Feb 2019 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/2019_01_01/</guid>
      <description>1 strtotime() 描述 获取上个月的时间可以是date(&amp;lsquo;Y-m-d&amp;rsquo;,strtotime(&#39;-1 month&#39;));如果今天是31号而上个月没有31号，就会直接输出这个月1号； 解决办法 使用last day of -1 month来获取上个月的最后一天
2 php 字符串和数字比较 描述 遇到一个问题，传过来的参数可能是0，可能是字符串，然后与0作比较，但是当传递的参数是字符串时，与0比较，结果是true 解决办法 直接与&#39;0&amp;rsquo;比较。0===&amp;lsquo;0&amp;rsquo;可以返回true,可以直接比较，字符串与&#39;0&amp;rsquo;比较也不等
3 virtualbox共享文件夹不能执行virtualenv env，只能在其他文件夹下运行，暂时没想到解决办法 virtualbox的共享文件夹有保护机制，不允许直接运行virtualenv env，只能在其他文件夹下运行,解决办法： 硬链接
4 laravel get()-&amp;gt;toArray()无法获取数据 </description>
    </item>
    
  </channel>
</rss>
