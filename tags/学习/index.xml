<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on </title>
    <link>https://laurel-he.github.io/tags/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 26 Sep 2021 13:47:00 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/tags/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>pcntl</title>
      <link>https://laurel-he.github.io/php/pcntl/</link>
      <pubDate>Sun, 26 Sep 2021 13:47:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/php/pcntl/</guid>
      <description>pcntl_wait:等待或返回fork的子进程状态</description>
    </item>
    
    <item>
      <title>c语言基础介绍</title>
      <link>https://laurel-he.github.io/corc&#43;&#43;/c/01basic/</link>
      <pubDate>Sat, 04 Sep 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/corc&#43;&#43;/c/01basic/</guid>
      <description>本系列来自于中国大学MOOC的 程序设计入门C语言 学习视频总结
基础 学习程序设计的目的 通过学习程序设计，理解计算机如何工作，计算机擅长做什么，不擅长做什么。
计算机如何解决问题？ 告诉计算机的步骤，它会一步一步地去做。告诉计算机How to do而不是what to do
编程语言的作用 编程语言的作用是，写下要计算机做事的步骤，让计算机去做。
计算机懂什么语言？ 16进制数字组成的机器码，
示例： 利用辗转相除法计算两个数的最大公约数： int u = 32; int v = 26; while (v != 0) { int temp = u % v; u = v; v = temp; } printf(&amp;#34;%d&amp;#34;, u); 计算机语言:计算机可以理解的语言，人几乎无法看懂 程序：程序员能够理解的语言 算法：描述成普通人可以理解的语言 要让计算机做的事情都是计算，我们要做的是把计算的步骤找到告诉计算机，计算的步骤叫做算法。
计算机的思维方式 枚举，二分法。。。
计算机如何执行程序？ 解释：一步一步将代码解释给计算机 编译：先有一个程序，把程序翻译出来，直接用翻译后的程序去执行 对于计算机的编程语言来说，语言本身没有解释和编译的区分的，任何语言都是既可以编译执行也可以解释执行， 只是有的习惯不同，例如C语言一般是编译执行，但是也可以使用解释器。
C语言优点 为什么选择C语言： 使用范围广，做操作系统，嵌入式系统几乎没有其他选择，现代的编程语言在语法上的差异很小，基本都和C语言接近 针对各种应用的库可以完成大量工作，一般说某种语言厉害是因为它有更合适的库。 高效性，可移植性，功能丰富，面向程序员，灵活性
简单历史 指针是C语言的灵魂，发展自B语言。
线上开发环境 暂时采用codeBlocks(教程中使用的是dev C++，但是个人感觉界面太丑)</description>
    </item>
    
    <item>
      <title>开始编程</title>
      <link>https://laurel-he.github.io/corc&#43;&#43;/c/02first/</link>
      <pubDate>Sat, 04 Sep 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/corc&#43;&#43;/c/02first/</guid>
      <description>本系列来自于中国大学MOOC的 程序设计入门C语言 学习视频总结
第一个程序 #include &amp;lt;stdio.h&amp;gt; int main(int argc, char ** argv) { printf(&amp;#34;Hello Word\n&amp;#34;); int i = 0; scanf(&amp;#34;%d&amp;#34;, &amp;amp;i); printf(&amp;#34;The res is: %d&amp;#34;, i + 10); return 0; } 程序的框架就是：
#include &amp;lt;stdio.h&amp;gt;int main(){return 0;}换行和空格不意味着任何问题。
浮点数 float</description>
    </item>
    
    <item>
      <title>表达式</title>
      <link>https://laurel-he.github.io/corc&#43;&#43;/c/03expression/</link>
      <pubDate>Sat, 04 Sep 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/corc&#43;&#43;/c/03expression/</guid>
      <description></description>
    </item>
    
    <item>
      <title>26. 删除有序数组中的重复项</title>
      <link>https://laurel-he.github.io/acm/leetcode/26removeduplicates/</link>
      <pubDate>Fri, 03 Sep 2021 19:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/26removeduplicates/</guid>
      <description>题目来源26. 删除有序数组中的重复项
题目描述 难度 简单
描述 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明: 为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &amp;lt; len; i++) {print(nums[i]);}示例 1： 输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2： 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</description>
    </item>
    
    <item>
      <title>36. 有效的数独</title>
      <link>https://laurel-he.github.io/acm/leetcode/36effecttivesudoku/</link>
      <pubDate>Fri, 03 Sep 2021 19:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/36effecttivesudoku/</guid>
      <description>题目来源：36. 有效的数独
描述 请你判断一个9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字1-9在每一行只能出现一次。 数字1-9在每一列只能出现一次。 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用&#39;.&amp;lsquo;表示。
注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。
示例 1： 输入：board = [[&amp;ldquo;5&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;] ,[&amp;ldquo;4&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;] ,[&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;5&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;9&amp;rdquo;]] 输出：true
示例 2： 输入：board = [[&amp;ldquo;8&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;] ,[&amp;ldquo;4&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;ldquo;3&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;1&amp;rdquo;] ,[&amp;ldquo;7&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;ldquo;6&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;5&amp;rdquo;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;8&amp;rdquo;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;9&amp;rdquo;]] 输出：false 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 &amp;lsquo;.&amp;rsquo;
自行解法 class Solution { /** * @param String[][] $board * @return Boolean */ function isValidSudoku($board) { $nineArr = [ [ $board[0][0], $board[0][1], $board[0][2], $board[1][0], $board[1][1], $board[1][2], $board[2][0], $board[2][1], $board[2][2]], [ $board[3][0], $board[3][1], $board[3][2], $board[4][0], $board[4][1], $board[4][2], $board[5][0], $board[5][1], $board[5][2], ], [ $board[6][0], $board[6][1], $board[6][2], $board[7][0], $board[7][1], $board[7][2], $board[8][0], $board[8][1], $board[8][2], ], [ $board[0][3], $board[0][4], $board[0][5], $board[1][3], $board[1][4], $board[1][5], $board[2][3], $board[2][4], $board[2][5]], [ $board[3][3], $board[3][4], $board[3][5], $board[4][3], $board[4][4], $board[4][5], $board[5][3], $board[5][4], $board[5][5], ], [ $board[6][3], $board[6][4], $board[6][5], $board[7][3], $board[7][4], $board[7][5], $board[8][3], $board[8][4], $board[8][5], ], [ $board[0][6], $board[0][7], $board[0][8], $board[1][6], $board[1][7], $board[1][8], $board[2][6], $board[2][7], $board[2][8]], [ $board[3][6], $board[3][7], $board[3][8], $board[4][6], $board[4][7], $board[4][8], $board[5][6], $board[5][7], $board[5][8], ], [ $board[6][6], $board[6][7], $board[6][8], $board[7][6], $board[7][7], $board[7][8], $board[8][6], $board[8][7], $board[8][8], ], ]; foreach ($nineArr as $checkNine) { if (!</description>
    </item>
    
    <item>
      <title>118. 杨辉三角</title>
      <link>https://laurel-he.github.io/acm/leetcode/118pascalstriangle/</link>
      <pubDate>Fri, 03 Sep 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/118pascalstriangle/</guid>
      <description>题目来源：118. 杨辉三角
题目描述 给定一个非负整数numRows，生成「杨辉三角」的前numRows行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
示例2: 输入: numRows = 1 输出: [[1]]
提示: 1 &amp;lt;= numRows &amp;lt;= 30
自行解法 可以判断出以下结论： （1）每一项的第一个和最后一个都是1 （2）每一项的个数等于所在项的位置 （3）每一项除开第一个和最后一个数字，假设所在位置为i，其他的数字应该等于上一项的i-1和i下标的值之和 根据以上结论可以实现如下代码：
class Solution { /** * @param Integer $numRows * @return Integer[][] */ function generate($numRows) { $ret = []; for ($i = 0; $i &amp;lt; $numRows; $i++) { $cont = []; for ($j = 0; $j &amp;lt; $i + 1; $j ++) { if ($j == 0 || $j == $i) { $cont[$j] = 1; } else { $cont[$j] = $ret[$i - 1][$j - 1] + $ret[$i - 1][$j]; } } $ret[$i] = $cont; } return $ret; } } 其他优质解法分析 </description>
    </item>
    
    <item>
      <title>原地算法</title>
      <link>https://laurel-he.github.io/acm/junioralgorithm/in-placealgorithm/</link>
      <pubDate>Fri, 03 Sep 2021 12:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/junioralgorithm/in-placealgorithm/</guid>
      <description>概念 在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。 当算法执行时，输入的资料通常会被要输出的部分覆盖掉。 不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。</description>
    </item>
    
    <item>
      <title>88.合并两个有序数组</title>
      <link>https://laurel-he.github.io/acm/leetcode/88arraymerge/</link>
      <pubDate>Wed, 01 Sep 2021 18:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/88arraymerge/</guid>
      <description>题目来源：88.合并两个有序数组
描述 给你两个按 非递减顺序 排列的整数数组nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。</description>
    </item>
    
    <item>
      <title>1.两数之和</title>
      <link>https://laurel-he.github.io/acm/leetcode/1towsum/</link>
      <pubDate>Wed, 01 Sep 2021 12:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/1towsum/</guid>
      <description>题目链接：1.两数之和
题目描述 难度 简单 描述 给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2]
示例 3： 输入：nums = [3,3], target = 6 输出：[0,1]
提示：
2 &amp;lt;= nums.length &amp;lt;= 104 -109 &amp;lt;= nums[i] &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 只会存在一个有效答案 进阶： 你可以想出一个时间复杂度小于 O(n2) 的算法吗？</description>
    </item>
    
    <item>
      <title>53.最大子序和</title>
      <link>https://laurel-he.github.io/acm/leetcode/53maxsum/</link>
      <pubDate>Tue, 31 Aug 2021 17:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/53maxsum/</guid>
      <description>题目链接：53.最大子序和
题目描述 难度 简单 描述 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组[4,-1,2,1] 的和最大，为6 。
示例 2： 输入：nums = [1] 输出：1
示例 3： 输入：nums = [0] 输出：0
示例 4： 输入：nums = [-1] 输出：-1
示例 5： 输入：nums = [-100000] 输出：-100000
提示： 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 105
进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
自行解法 一开始并没有想到合适的解法，于是想到最暴力的方式，获取所有子序和并比较
class Solution { /** * 出所有的子序和之后进行比较 * @param Integer[] $nums * @return Integer */ function maxSubArray($nums) { $maxForI = []; for ($i = 0; $i &amp;lt; count($nums); $i++) { $sumForI = $nums[$i]; $maxForJ = []; $max = max($nums); for ($j = $i + 1; $j &amp;lt; count($nums); $j++) { if ($i == $j) { $sumForI = $nums[$i]; } else { $sumForI += $nums[$j]; } $maxForJ[] = max($maxNum, $sumForI, $max); $maxNum = $sumForI; } if (count($nums) == 1) { $maxForJ = $nums; } $maxForI[$i] = max($maxForJ); } return max($maxForI); } } 这种方式可以通过绝大部分测试用例，但是当$nums增加到一定数量级后会超时</description>
    </item>
    
    <item>
      <title>122. 买卖股票的最佳时机</title>
      <link>https://laurel-he.github.io/acm/leetcode/121buyshares/</link>
      <pubDate>Tue, 31 Aug 2021 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/121buyshares/</guid>
      <description>题目链接：122. 买卖股票的最佳时机
题目描述 难度 简单 描述 给定一个数组 prices ，它的第i 个元素prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
提示： 1 &amp;lt;= prices.length &amp;lt;= 105 0 &amp;lt;= prices[i] &amp;lt;= 104
自行解法 暴力解法 暴力解法虽然可以实现，但当数组超出一定长度时会超时
class Solution { /** * @param Integer[] $prices * @return Integer */ function maxProfit($prices) { $countPri = count($prices); $diff = []; for ($i = 0; $i &amp;lt; $countPri; $i++) { $maxDiff = 0; for ($j = $i + 1; $j &amp;lt; $countPri; $j ++) { if ($prices[$j] - $prices[$i] &amp;gt; $maxDiff) { $maxDiff = ($prices[$j] - $prices[$i]); } } $diff[] = $maxDiff; } return max($diff); } } 动态规划(DP)：</description>
    </item>
    
    <item>
      <title>go基础</title>
      <link>https://laurel-he.github.io/go/basic/</link>
      <pubDate>Fri, 27 Aug 2021 13:47:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/go/basic/</guid>
      <description>本系列参考go语言教程
基础概念 go语言特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速
go语言用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。 它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。
简单的go语言程序 package main import &amp;#34;fmt&amp;#34; func main() { var age, name string = &amp;#34;18&amp;#34;, &amp;#34;Joe&amp;#34; var res = fmt.Sprintf(&amp;#34;my name is %s, and my age is %s&amp;#34;, name, age) fmt.Println(res) } func init() { fmt.Println(&amp;#34;test init&amp;#34;) } func varTest() { var funcName, funcTime string = &amp;#34;varTest&amp;#34;, &amp;#34;now&amp;#34; fmt.Println(funcName + funcTime) } 使用go run来执行 使用go build 来生成二进制文件</description>
    </item>
    
    <item>
      <title>操作系统（1）-基础和vim操作</title>
      <link>https://laurel-he.github.io/post/opratingsystem_01/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/opratingsystem_01/</guid>
      <description>本系列来源于蓝桥：https://www.lanqiao.cn/courses/2610 同系列文已发布在CSDN
命令行中的shell通配符    字符 含义     * 匹配0或多个字符   ? 匹配任意一个字符   [list] 匹配 list 中的任意单一字符   [^list] 匹配 除list 中的任意单一字符以外的字符   [c1-c2] 匹配 c1-c2之间的任意单一字符   {string1, string2&amp;hellip;} 匹配 string1 或 string2 (或更多)其一字符串   {c1..c2} 匹配 c1-c2 中全部字符 如{1..10}    示例 创建用户lilei sudo adduser lilei
将lilei加入sudo组 sudo usermod -G sudo lilei
删除用户lilei sudo deluser lilei &amp;ndash;remove-home</description>
    </item>
    
    <item>
      <title>操作系统（2）-进程管理</title>
      <link>https://laurel-he.github.io/post/opratingsystem_02/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/opratingsystem_02/</guid>
      <description>蓝桥操作系统课程的学习笔记
top 实时查看进程的状态 top第一行
   内容 解释     top 表示当前程序的名称   14:11:28 当前系统的时间   up 231 days, 20:31 表示改机器已经启动了多长时间   1 user 表示当前系统只有一个用户   load average: 0.24, 0.32, 0.19 分别对应1、5、15分钟内cpu的平均负载   top第二行    内容 解释   &amp;ndash; &amp;ndash;   Tasks: 26 toal 进程总数   1 running 1个正在运行的进程   25 sleeping 25个正在睡眠的进程数   0 stopped 没有停止的进程数   0 zombie 没有僵尸进程数   top第三行    基本是cpu使用情况的统计    内容 解释   &amp;ndash; &amp;ndash;   Cpu(s):1.</description>
    </item>
    
    <item>
      <title>操作系统（3）</title>
      <link>https://laurel-he.github.io/post/opratingsystem_03/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/opratingsystem_03/</guid>
      <description>Linux实现模拟多进程并发执行 示例：
#!/bin/bash for((i=0;i&amp;lt;5;i++)) do { sleep 1; echo &amp;#34;$i--&amp;#34;&amp;gt;&amp;gt;aa &amp;amp;&amp;amp; echo &amp;#34;done&amp;#34; }&amp;amp; done wait cat aa | wc -l rm aa 解析 &amp;amp;代表并发执行，wait等待前面执行完了再执行，例如此示例中，如果没有wait很可能还没创建aa文件
Linux下的中断 #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; int main(void) { pid_t pid; //pid  printf(&amp;#34;Before fork... &amp;#34;); switch( pid = fork()) { case -1: printf(&amp;#34;fork call fail &amp;#34;); fflush(stdout); exit(1); case 0: printf(&amp;#34;child call &amp;#34;); printf(&amp;#34;the pid of child is %d &amp;#34;, getpid()); printf(&amp;#34;the pid of child&amp;#39;s parent is %d &amp;#34;, getppid()); printf(&amp;#34;child exiting.</description>
    </item>
    
    <item>
      <title>数据结构学习笔记-1</title>
      <link>https://laurel-he.github.io/datastruct/datastruct_01/</link>
      <pubDate>Tue, 20 Jul 2021 16:34:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/datastruct/datastruct_01/</guid>
      <description>数据结构学习系列都来自于中国大学MOOC上的浙江大学数据结构学习课程。原课程代码全部采用C语言实现，由于本菜平时最擅长（zhihuiyong）使用php，因此所有算法全部翻译成了php实现。课程链接：数据结构 全文已同步发布到CSDN
定义 （1）数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义和相关的函数来给出 （2）数据结构是ADT(abstruct data type)的物理实现 （3）数据结构是计算机存储，组织数据的方式，通常情况下，精心选择的数据结构可以带来最有效率的算法
示例 写程序实现一个函数printN，打印从1-N之间的所有正整数 。以下是两种实现方式的php实现代码：
&amp;lt;?php function printN($n) { $i = 0; for($i = 0; $i &amp;lt; $n; $i++) { echo $i. &amp;#34;\n\r&amp;#34;; } } $begin1 = microtime(); printN(10000); $end1 = microtime(); $time1 = $end1 - $begin1; function printM($m) { if ($m) { printM($m - 1); echo $m. &amp;#34;\n\r&amp;#34;; } } $begin2 = microtime(); printM(10000); $end2 = microtime(); $time2 = $end2 - $begin2; echo $time2 - $time1; 递归和直接循环打印都可以实现，但是递归当数字大于1w左右就失败了，因为递归对空间的占用十分恐怖。解决问题方法的效率，也与空间的占用效率是有关的。</description>
    </item>
    
    <item>
      <title>mysql必知必会学习笔记-1-基础概念</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</link>
      <pubDate>Fri, 02 Apr 2021 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</guid>
      <description>概念 定义 数据库 数据库是用来保存有组织的数据的容器
表 某种特定类型数据的结构化清单（在类似mongodb等nosql数据库中，表的类型和字段都不是固定的）
列 表中的一个字段，所有的表都是由一个或多个列组成的
数据类型 所容许的数据类型，每个表列都有 相应的数据类型，它限制或容许改列中存储的数据
行 表中的一个记录
主键 一列（或一组列），其值能够唯一区分表中的每一行 主键建议 （1）不更新主键列中的值 （2）不重用组件列的值 （3）不在主键列中使用可能会更改的值
mysql命令行连接参数 经常使用的参数:
   参数 解释     u 用户名   h host   P 端口号   p 密码    </description>
    </item>
    
    <item>
      <title>1175. 质数排列</title>
      <link>https://laurel-he.github.io/acm/leetcode/1175primesort/</link>
      <pubDate>Thu, 03 Sep 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/1175primesort/</guid>
      <description>题目来源:1175. 质数排列
题目描述 难度 简单
描述 请你帮忙给从 1 到 n的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。
让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。
由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。
 示例 1：
输入：n = 5 输出：12 解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。 示例 2：
输入：n = 100 输出：682289015
提示：
1 &amp;lt;= n &amp;lt;= 100
自我解法 </description>
    </item>
    
    <item>
      <title>566. 重塑矩阵</title>
      <link>https://laurel-he.github.io/acm/leetcode/566remouldmatrix/</link>
      <pubDate>Thu, 03 Sep 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/566remouldmatrix/</guid>
      <description>题目来源:566. 重塑矩阵
题目描述 难度 简单
描述 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。
给你一个由二维数组 mat 表示的m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。
重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。
如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。
示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]]
示例 2： 输入：mat = [[1,2],[3,4]], r = 2, c = 4 输出：[[1,2],[3,4]]
提示： m == mat.length n == mat[i].length 1 &amp;lt;= m, n &amp;lt;= 100 -1000 &amp;lt;= mat[i][j] &amp;lt;= 1000 1 &amp;lt;= r, c &amp;lt;= 300</description>
    </item>
    
    <item>
      <title>350. 两个数组的交集 II</title>
      <link>https://laurel-he.github.io/acm/leetcode/350arrat/</link>
      <pubDate>Wed, 02 Sep 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/350arrat/</guid>
      <description>题目链接350. 两个数组的交集 II
题目描述 难度 简单
描述 给定两个数组，编写一个函数来计算它们的交集。
示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2]
示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9]
说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。
进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果nums1的大小比nums2小很多，哪种方法更优？ 如果nums2的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
自行解法 思路 这里需要获取两个数组的交集，php有一个函数（array_intersect）可以获取两个数组的交集，但是和要求不符合。 当某个元素在数组a中存在，且在数组b中存在不止一次，array_intersect获得的交集不正确。 因此分析，可以直接循环较短的数组，和另一个较长的数组比较，当获得了一个交集元素的时候，就删除被比较的元素，代码如下：
class Solution { function delOneFromArr($val, $delArr) { /** 删除数组中一个值为$val的数据 */ foreach($delArr as $key =&amp;gt; $arr) { if ($arr == $val) { unset($delArr[$key]); break; } } return $delArr; } /** * @param Integer[] $nums1 * @param Integer[] $nums2 * @return Integer[] */ function intersect($nums1, $nums2) { /** 循环较短的数组，挨个判断 */ list($checkArr, $otherArr) = count($nums1) &amp;gt;= count($nums2) ?</description>
    </item>
    
    <item>
      <title>217.存在重复元素</title>
      <link>https://laurel-he.github.io/acm/leetcode/217repeat/</link>
      <pubDate>Mon, 31 Aug 2020 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/acm/leetcode/217repeat/</guid>
      <description>题目链接：217.存在重复元素
题目描述 难度 简单 描述 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
示例 1: 输入: [1,2,3,1] 输出: true
示例 2: 输入: [1,2,3,4] 输出: false
示例3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
自行解法 直接循环，判断每个元素和剩余的其他元素是否重复，不重复则去除这个元素，继续比较
class Solution { /** * @param Integer[] $nums * @return Boolean */ function containsDuplicate($nums) { $dataCheck = $nums; for ($i = 0; $i &amp;lt; count($nums); $i++) { $check = $nums[$i]; unset($dataCheck[$i]); if (in_array($check, $dataCheck)) { return true; } } return false; } } 其他优质解法 先去重，判断去重后的长度是否比之前的长度短，是则说明有重复</description>
    </item>
    
    <item>
      <title>kustomize使用文档</title>
      <link>https://laurel-he.github.io/post/kustomize01/</link>
      <pubDate>Thu, 21 May 2020 11:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/kustomize01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>kubenetes权威指南1-2章</title>
      <link>https://laurel-he.github.io/post/k8s01/</link>
      <pubDate>Sat, 16 May 2020 18:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/k8s01/</guid>
      <description>kubenetes是什么 k8s是一个全新的基于容器技术的分布式架构领先方案，一个开放的开发平台，一个完备的分布式系统支撑平台
k8s重要资源对象介绍 Master 概念介绍 k8s中的Master指的是集群控制节点，在每个集群里都需要有一个Master来负责整个集群的管理和控制。
关键进程 （1）Kubenetes API Server(kube-apiserver):提供了HTTP Rest接口的额关键服务进程，是 kubenetes里所有资源的增删改查等操作的唯一入口，也是集群控制的入口进程 （2）kubenetes Controller Manager(kube-controller-manager):kubenetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的大总管 （3）Kubenetes Scheduler(kube-scheduler):负责资源调度(Pod调度)的进程，相当于哦公交公司的调度室
Node 概念介绍 除了Master,Kubenetes集群中的其他机器被称为Node。Node是集群中的工作负载节点，每个Node都会被Master分配一些工作负载(Docker容器)，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上
关键进程 （1）kubelet:负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，，实现集群管理的基本功能 （2）kube-proxy:实现kubenetes Service的通信与负载均衡的重要组件 （3）Docker Engine：负责本机的容器的创建和管理工作
Pod 概念介绍 在Kubernetes中，最小的管理元素不是一个个独立的容器，而是Pod,Pod是最小的，管理，创建，计划的最小单元.
部分概念 （1）可以设置限额的计算资源有CPU和Memory两种： 通常以千分之一的CPU配额为最小单位，用m来表示 Memory配额也是一个绝对值，单位是内存字节数 （2）Event是一个事件的记录，记录了事件的最早产生事件，最后重现事件，重复次数，发起者，类型，以及导致此事件的原因等众多信息。
Label 概念 一个Label是一个key=value的键值对,可类似于sql查询语句一样来进行查询
Deployment Deployment内部使用了Replica Set来实现目的
kubectl的create命令和apply命令的区别 kubectl create：
（1）kubectl create命令，是先删除所有现有的东西，重新根据yaml文件生成新的。所以要求yaml文件中的配置必须是完整的
（2）kubectl create命令，用同一个yaml 文件执行替换replace命令，将会不成功，fail掉。
kubectl apply：
 kubectl apply命令，根据配置文件里面列出来的内容，升级现有的。所以yaml文件的内容可以只写需要升级的属性</description>
    </item>
    
    <item>
      <title>《第一本docker书》学习笔记01</title>
      <link>https://laurel-he.github.io/post/docker01/</link>
      <pubDate>Tue, 21 Apr 2020 21:03:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/docker01/</guid>
      <description>Docker与配置管理 docker的核心组件 （1）docker客户端和服务器，也称为docker引擎 （2）docker镜像 （3）Registry （4）Docker容器
基本使用 docker info 查看docker程序是否存在，功能是否正常
docker exec(docker run) docker run 命令提供了docker容器的创建到启动的功能 (1)-i:保证容器STDIN是开启的 (2)-t:为要撞见的容器分配一个伪tty终端 docker exec -it backend_jiapin /bi n/bash</description>
    </item>
    
    <item>
      <title>linux命令大全</title>
      <link>https://laurel-he.github.io/linux/linuxope/</link>
      <pubDate>Thu, 27 Feb 2020 18:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/linux/linuxope/</guid>
      <description>系统信息 arch 描述
显示机器的处理器架构 举例
uname 描述
显示机器的处理器架构 参数
-a或&amp;ndash;all 显示全部的信息。 -m或&amp;ndash;machine 显示电脑类型。 -n或-nodename 显示在网络上的主机名称。 -r或&amp;ndash;release 显示操作系统的发行编号。 -s或&amp;ndash;sysname 显示操作系统名称。 -v 显示操作系统的版本。 &amp;ndash;help 显示帮助。 &amp;ndash;version 显示版本信息。 举例
dmidecode 描述
显示硬件信息，不常用，可忽略
开关机 shutdown 描述
关机或重启 参数
-t seconds : 设定在几秒钟之后进行关机程序。 -k : 并不会真的关机，只是将警告讯息传送给所有使用者。 -r : 关机后重新开机。 -h : 关机后停机。 -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。 -c : 取消目前已经进行中的关机动作。 -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。 -F : 关机时，强迫进行 fsck 动作。 time : 设定关机的时间。 message : 传送给所有使用者的警告讯息。</description>
    </item>
    
    <item>
      <title>linux命令大全</title>
      <link>https://laurel-he.github.io/linux/linuxuse/</link>
      <pubDate>Thu, 27 Feb 2020 18:00:00 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/linux/linuxuse/</guid>
      <description>文件操作 cat 描述
查看文件内容 参数
-n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting 举例 1 从键盘创建一个文件： 2 将几个文件合并成一个文件： cd 描述</description>
    </item>
    
    <item>
      <title>计算相关</title>
      <link>https://laurel-he.github.io/learn/codecollect/</link>
      <pubDate>Tue, 25 Feb 2020 20:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/learn/codecollect/</guid>
      <description>1 计算矩形是否相交 描述 给定两个矩形的左上角起始点坐标和矩形的宽，高，计算这两个矩形是否相交 分析 1 矩形1左上角坐标p1,右下角坐标p2,矩形2左上角坐标p3,右下角坐标p4 2 M点坐标为P1与P3点在X方向较大值与Y方向较大值的交点 3 N点坐标为P2与P4点在X方向较小值与Y方向较小值的交点 4 如果M点的X坐标和Y坐标值均比N点相应的X坐标和Y坐标值小，亦即M和N可以分别构成一个矩形的左上角点和右上角点，则两矩形相交；其余情况则不相交 代码
&amp;lt;?php function checkRectInterSect($rect1, $rect2) { $x1 = $rect1[&amp;#39;x&amp;#39;]; $w1 = $rect1[&amp;#39;w&amp;#39;]; $y1 = $rect1[&amp;#39;y&amp;#39;]; $h1 = $rect1[&amp;#39;h&amp;#39;]; $x2 = $rect2[&amp;#39;x&amp;#39;]; $w2 = $rect2[&amp;#39;w&amp;#39;]; $y2 = $rect2[&amp;#39;y&amp;#39;]; $h2 = $rect2[&amp;#39;h&amp;#39;]; $p1 = [$x1, $y1]; $p2 = [$x1 + $w1, $y1 + $h1]; $p3 = [$x2, $y2]; $p4 = [$x2 + $w2, $y2 + $h2]; $M = [max($p1[0], $p3[0]), max($p1[1], $p1[1])]; $N = [min($p2[0], $p4[0]), min($p2[1], $p4[1])]; if ($M[0] &amp;lt; $N[0] &amp;amp;&amp;amp; $M[1] &amp;lt; $N[1]) { return true; } else { return false; } } ?</description>
    </item>
    
    <item>
      <title>运行相关</title>
      <link>https://laurel-he.github.io/learn/codecollect2/</link>
      <pubDate>Tue, 25 Feb 2020 20:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/learn/codecollect2/</guid>
      <description>1 下载数据 描述 根据链接下载文件 代码
&amp;lt;?php function downloadOldFile($url,$rename,$ext){ $file_path = &amp;#39;public/images/age_60-120/&amp;#39;; $ch = curl_init($url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_BINARYTRANSFER, 1); $rawdata=curl_exec ($ch); curl_close ($ch); // 使用中文文件名需要转码  $fp = fopen($file_path. $rename .&amp;#34;.&amp;#34;.$ext,&amp;#39;w&amp;#39;); fwrite($fp, $rawdata); fclose($fp); // 返回路径  return $_SERVER[&amp;#39;DOCUMENT_ROOT&amp;#39;].$file_path.$rename.&amp;#34;.&amp;#34;.$ext; } ?&amp;gt;2 按步骤执行方法 描述 经常有需求：分页执行脚本，例如前1000条执行完后继续分页，此时就需要自动跳页执行 代码
&amp;lt;?php /** * @param mixed ...$args * @return bool * @throws Exception */ private function stepRun(...$args) { $count = $args[0]; $method = $args[1]; $step = array_key_exists(2, $args) ?</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/design_singleton/</link>
      <pubDate>Tue, 29 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/design_singleton/</guid>
      <description>概念介绍 情景介绍 一个类只需要被实例化一次，但是不应该由调用方来判断是否被实例化过
基础介绍 所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。 类把构造方法设置为私有，使所有的方法都不能直接实例化这个类。然后类内部写一个公共方法来判断这个类是否被实例化过，调用方无需判断
单例模式 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 通常可以让一个全局变量使得一个对象被访问，但它不能防止实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</description>
    </item>
    
    <item>
      <title>代码整洁之道1-9章</title>
      <link>https://laurel-he.github.io/learn/cleancode/</link>
      <pubDate>Mon, 07 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/learn/cleancode/</guid>
      <description>提要 要有代码：代码呈现了需求的细节，将需求明确到机器可以执行的细节程度 不要产生糟糕的、混乱的代码，勒布朗法则：稍后等于永不 制造混乱无益于赶上期限，做得快的唯一方法就是始终保持代码整洁。
好代码的特点 优雅、搞笑；代码逻辑直截了当，缺陷难以隐藏； 尽量减少依赖关系，使之便于维护； 根据某种分层战略完善处理错误代码，性能调至最优 整洁的代码力求集中，每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染 整洁的代码可由作者之外的开发者阅读和增补，它应当有单元测试和验收测试 尽量使用有意义的命名，它只提供一种而非多种做一件事的途径 尽量少的依赖关系，明确地定义和提供清晰、尽量少的API
总结 （1）能通过所有测试 （2）没有重复代码 （3）体现系统中的全部设计理念 （4）包含尽量少的实体，比如类、方法、函数等 不要重复代码，只做一件事，表达力，小规模抽象
有意义的命名 （1）如果名称需要注释来补充，那就不算是名副其实（之前出现过争议） （2）不要使用意义含糊的废话，如果名称相同但是意义不同，那么info和data与a an the一样毫无意义，不要使用废话，varable不应出现在便能两种，table不应出现在表中 （3）使用读得出来的名称，方便阅读 （4）使用方便搜索的名称 （5）避免使用编码 （6）应当把类和函数做得足够小，消除对成员前缀的需要，读代码的人通常不会读前缀 （7）不要在类名中使用奇怪的命名 （8）不要使用双关语
函数 （1）函数应该尽可能小，20行封顶最佳 （2）每个函数都一目了然，每个函数都只说一件事，每个函数都依次带到下一个函数 （3）函数的缩进层不应该多余一层或两层
需要遵循的原则 （1）确保每隔switch函数都埋藏在较低的抽象层而且永远不重复 （2）不要向函数传入布尔值（我以前经常这么做），因为传入布尔值表示函数会有多余的操作 （3）使用异常代替返回错误码（错误代码能从主路径代码中分离出来得到简化） （4）抽离try/catch代码块 （5）不要重复自己
注释 注意 注释存在的时间越久，就离它所描述的代码越远，越来越变得全然错误，因为程序员不能坚持维护注释
必要的注释（好的注释） （1）法律信息 （2）提供信息的注释 （3）对意图的解释 （4）阐释（如果参数或返回值是某个标准库的一部分或者不能修改的代码，帮助阐释其含义的代码就会有用） （5）警示
单元测试 </description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/singlemode/</link>
      <pubDate>Sun, 06 Oct 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/singlemode/</guid>
      <description>基础介绍 概念介绍 作为对象的创建模式，单例模式确保某一个类只有一个实例，并且对外提供这个全局实例的访问入口。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。
单例模式三要素  需要一个保存类的唯一实例的静态成员变量。 构造函数和克隆函数必须声明为私有的，防止外部程序创建或复制实例副本。 必须提供一个访问这个实例的公共静态方法，从而返回唯一实例的一个引用。  </description>
    </item>
    
    <item>
      <title>工作经验总结</title>
      <link>https://laurel-he.github.io/post/work/</link>
      <pubDate>Sat, 05 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/work/</guid>
      <description>工作经验 （1）学会控制情绪</description>
    </item>
    
    <item>
      <title>代码大全</title>
      <link>https://laurel-he.github.io/learn/codecomplate_01/</link>
      <pubDate>Sat, 05 Oct 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/learn/codecomplate_01/</guid>
      <description>前期准备 前期准备的重要性 不要立即开始写代码，要做好必要的需求分析和架构设计，写好需求文档和技术文档，防止浪费时间和精力制造错误的东西
需求核对表 针对功能需求：
1．是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？
2．是否详细定义了系统的全部输出，包括其目的地、精度、取值范围、出现频率格式等？
3．是否详细定义了所有的输出格式(如：web页面、报表等)？
4．是否详细定义了所有硬件及软件的外部接口？
5．是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等？
6．是否列出了用户所要做的全部事情？
7．是否详细定义了每个任务所用数据，以及每个任务得到的数据
针对非功能需求（质量需求）
1.是否为全部必要的操作，从用户的角度，详细描述的期望的响应时间 ？
2.是否详细描述了其他与计时有关的考虑，如处理时间、数据传输率、系统吞吐量等？
3.是否详细定义了安全级别
4.是否详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检查与回复的策略等？
5.是否详细定义了机器内存和剩余硬盘空间最小值？
6.是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件接口变更的能力？
7.是否包含对“成功”的定义，“失败”的定义？
需求的质量
  需求是用户书写的吗？
  每条需求都不与其他需求冲突吗？
  是否详细定义了相互竞争的特性之间的权衡
  是否避免在需求中规定设计(方案)
  需求是否在详细程度上保持相当一致的水平？有些需求应当更详细的描述吗？有些需求应该更粗略的描述吗？
  需求是否足够清晰，即使转交给一个独立的小组去构建，他们也能理解吗？开发者也这么想吗？
  每个条款都与待解决的问题及解决方案相关吗？能从每个条款上溯到它的问题中的对应跟源吗？
  是否每条需求都是可测试的？是否可应进行独立的测试，以检验满不满足各项需求
  是否描述了所有可能对需求的改动，包括各项改动的可能性
  需求的完备性
1.对于在开始开发之前无法获得信息，是否详细描述了信息不完全的区域？
2.需求的完备度是否达到这种程度：如果产品满足所有需求，那么它就是可接受的？
3.你对全部需求都感觉舒服吗？你是否已经去掉了那些不可能完成的需求—那些只是为了安抚客户和老板的东西？
花费在前期准备上的时间长度 花费在问题定义，需求分析，软件架构上的时间依据项目的需要而变化，一般占据10%-20%的工作量和20%-30%的时间
良好的类接口 类的基础是抽象数据类型（我之前大部分时候没有使用抽象，只是把相关的方法和变量定义放在了一起，实际上是不符合面向对象变成原则的），抽象数据类型是指一些数据和 对这些数据所进行操作的集合。定义抽象类有助于代码规范，提高
创建类的原因 （1）为显示世界中的对象建模 （2）为抽象的对象建模 （3）降低复杂度 （4）隔离复杂度 （5）隐藏实现细节 （6）让代码更易重用 （7）把相关的操作包装到一起
应当避免的类 （1）避免创建万能类 （2）消除无关紧要的类 （3）避免用动词命名的类</description>
    </item>
    
    <item>
      <title>react单元测试</title>
      <link>https://laurel-he.github.io/post/reactunit/</link>
      <pubDate>Mon, 29 Jul 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/reactunit/</guid>
      <description>测试 ESLint 代码检查（分析JavaScript代码）,JSHint和JSLint是用于分析JavaScript代码的原生工具，并且可以为用户提供格式化代码的反馈意见；</description>
    </item>
    
    <item>
      <title>Leetcode刷题</title>
      <link>https://laurel-he.github.io/post/2019-03-07/</link>
      <pubDate>Fri, 26 Jul 2019 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/2019-03-07/</guid>
      <description>1 两数之和 描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] `</description>
    </item>
    
    <item>
      <title>python100例学习笔记</title>
      <link>https://laurel-he.github.io/python/20190202/</link>
      <pubDate>Sat, 02 Feb 2019 13:25:21 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/python/20190202/</guid>
      <description>四个数组成不重复三位数 描述 有四个数字，1,2,3,4，能组成多少个不重复的三位数 思考 原文分析：将所有的数字排列组合后去掉不满足条件的列 代码
num = 1; for i in range(1,5): for j in range(1,5): for k in range(1,5): if(i != k) and (i != j) and (j != k): print i,j,k num = num + 1 print num 扩展 循环三次效率很低，每次循环都是1-5，有没有更好的解决办法
2 </description>
    </item>
    
    <item>
      <title>各种奇怪的坑</title>
      <link>https://laurel-he.github.io/post/2019_01_01/</link>
      <pubDate>Fri, 01 Feb 2019 16:10:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/post/2019_01_01/</guid>
      <description>1 strtotime() 描述 获取上个月的时间可以是date(&amp;lsquo;Y-m-d&amp;rsquo;,strtotime(&#39;-1 month&#39;));如果今天是31号而上个月没有31号，就会直接输出这个月1号； 解决办法 使用last day of -1 month来获取上个月的最后一天
2 php 字符串和数字比较 描述 遇到一个问题，传过来的参数可能是0，可能是字符串，然后与0作比较，但是当传递的参数是字符串时，与0比较，结果是true 解决办法 直接与&#39;0&amp;rsquo;比较。0===&amp;lsquo;0&amp;rsquo;可以返回true,可以直接比较，字符串与&#39;0&amp;rsquo;比较也不等
3 virtualbox共享文件夹不能执行virtualenv env，只能在其他文件夹下运行，暂时没想到解决办法 virtualbox的共享文件夹有保护机制，不允许直接运行virtualenv env，只能在其他文件夹下运行,解决办法： 硬链接
4 laravel get()-&amp;gt;toArray()无法获取数据 </description>
    </item>
    
  </channel>
</rss>
