<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Designpatterns on </title>
    <link>https://laurel-he.github.io/designpattern/</link>
    <description>Recent content in Designpatterns on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 07 May 2020 20:20:10 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/designpattern/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>设计模式从头学习-面向对象设计原则概述</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/design_pattern02/</link>
      <pubDate>Thu, 07 May 2020 20:20:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/design_pattern02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>设计模式从头学习-前言</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/design_patter01/</link>
      <pubDate>Thu, 07 May 2020 20:13:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/design_patter01/</guid>
      <description>注意 本文参考了书籍《大话设计模式》和文章从招式与内功谈起——设计模式概述 #写作初衷 我有空的时候就会学习一下设计模式，零零散散半年过去了，真正能够静下心来学习 设计模式的事件少之又少，而且很多模式例如单例模式，命令模式等我学过后就忘了，让我现在再 复述或者使用我又需要重新去学一下，因此我抛弃以前学习的零零散散的与设计模式相关的东西， 尝试从头再学一次，边学边使用，并做好详细的笔记，以后可以直接翻阅。 #设计模式的作用 (1)设计模式经过多年的使用和实践，包含了大量成功的，可维护可复用的设计方案，在很多情况下，设计模式可以提高开发效率，节约时间 (2)设计模式跨语言、跨平台、跨应用、跨国界，提供了通用的词汇和使用方式，节约交流时间 (3)大部分设计模式都兼顾了系统的可重用性和扩展性，这使很多系统可以重用，减少代码重复 (4)合理使用设计模式有助于别人理解自己的代码 (5)有助于更为深刻地理解面对对象编程 #如何掌握设计模式 a.这个设计模式的意图是什么 b.它要解决一个什么问题 c.什么时候可以使用它 d.它是如何解决问题的 e.掌握它的结构图 f.记住它的关键代码 g.能够想到至少两个它的应用实例，一个生活中的，一个软件中的 h.这个模式的优缺点是什么 i.在使用时要注意什么 #注意事项 （1）最好的掌握设计模式的方法是使用它们 （2）千万不要滥用模式</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/design_singleton/</link>
      <pubDate>Tue, 29 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/design_singleton/</guid>
      <description>概念介绍 情景介绍 一个类只需要被实例化一次，但是不应该由调用方来判断是否被实例化过
基础介绍 所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。 类把构造方法设置为私有，使所有的方法都不能直接实例化这个类。然后类内部写一个公共方法来判断这个类是否被实例化过，调用方无需判断
单例模式 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 通常可以让一个全局变量使得一个对象被访问，但它不能防止实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</description>
    </item>
    
    <item>
      <title>设计模式六大原则</title>
      <link>https://laurel-he.github.io/designpattern/others/codeprinceple/</link>
      <pubDate>Mon, 07 Oct 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/others/codeprinceple/</guid>
      <description>本文参考了设计模式六大原则
单一职责原则（SPR:Single Responsibility Principle） 一个类应该有且仅有一个原因导致该类的变更，即一个类应该只负责一项职责 但是在实际工作中，职责是会扩散的，一个类可能会新增更多的职责， 只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则
遵循单一职责原的优点： （1）可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； （2）提高类的可读性，提高系统的可维护性； （3）变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。
第二：里氏替换原则（LSP:Liskcov Substitution Principle） 定义 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 可以简单的理解为子类型能够替换它们的基类型
含义解析 （1）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 （2）子类中可以增加自己特有的方法。 （3）当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 （4）当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格
违反里氏替换原则的危害 （1）反直觉。期望所有子类行为是一致的，但如果不一致可能需要文档记录，或者在代码跑失败后涨此知识； （2）不可读。如果子类行为不一致，可能需要不同的逻辑分支来适配不同的行为，徒增代码复杂度； （3）不可用。可能出错的地方终将会出错。 如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替
第三：依赖倒置原则（DIP:Dependence Inversion Principle） 定义 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象 针对接口编程，不要针对实现编程
解释 依赖倒置原则基于这样一个事实： 相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。 在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。
示例 /** * 高层类Library需要实现readContent，但是readContent针对不同 * 类有不同的表现形式，于是抽象出来，这样不管怎么扩展修改，Library不用改 **/ class DesignController { /** *yii design/run */ public function actionRun() { $user = new User(); $data = $user-&amp;gt;gotoLibrary(); var_dump($data); } } class User { public function gotoLibrary() { $book = (new Library())-&amp;gt;read(new Book()); $news = (new Library())-&amp;gt;read(new Newspaper()); return [$book, $news]; } } class Library { public function read(IReader $reader) { return $reader-&amp;gt;readContent(); } } interface IReader { /** * 读取内容 * @return mixed */ public function readContent(); } class Book implements IReader { public function readContent() { return &amp;#39;书籍：小王子&amp;#39;; } } class Newspaper implements IReader { public function readContent() { return &amp;#39;报纸：今天奥运会结束了&amp;#39;; } } 第四：接口隔离原则(ISP:Interface Segregation Principle) 定义 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/singlemode/</link>
      <pubDate>Sun, 06 Oct 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/singlemode/</guid>
      <description>基础介绍 概念介绍 作为对象的创建模式，单例模式确保某一个类只有一个实例，并且对外提供这个全局实例的访问入口。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。
单例模式三要素  需要一个保存类的唯一实例的静态成员变量。 构造函数和克隆函数必须声明为私有的，防止外部程序创建或复制实例副本。 必须提供一个访问这个实例的公共静态方法，从而返回唯一实例的一个引用。  </description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/strategy/</link>
      <pubDate>Mon, 29 Jul 2019 14:37:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/strategy/</guid>
      <description>概念 定义 策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，该模式让算法独立于使用它的客户而独立变化
组成 1 抽象策略角色：策略类，通常由一个接口或者抽象类实现 2 具体策略角色：包装了相关的算法和行为。 3 环境角色：持有一个策略类的引用，最终给客户端调用。
分析 策略模式用一个抽象策略角色提供一个类（一般是接口或抽象类），每个策略都实现了这个抽象策略角色，环境角色去调用（依赖注入）
代码 &amp;lt;?php /** * @author: hexiaojiao@jiapinai.com * @todo: * time: 2019-07-30 20:07 */ /** * 定义抽象角色类` * Interface CollectInter */ interface CollectInter { public function collect($price, $num); public function input(); } class Base { public function input($discount = 1) { fwrite(STDOUT, &amp;#39;请输入单价&amp;#39;); $price = trim(fgets(STDIN)); fwrite(STDOUT, &amp;#39;请输入数量&amp;#39;); $num = trim(fgets(STDIN)); $res = $this-&amp;gt;collect($price, $num, $discount); return $res; } } /** * 定义具体策略类 * Class Collect02 */ class Collect02 extends Base implements CollectInter { public function collect($price, $num, $discount = 1) { var_dump(&amp;#39;Collect02:&amp;#39;, $price * $num * $discount); return true; } } /** * Class Discount */ class Discount extends Base implements CollectInter { public function collect($price, $num, $discount = 0.</description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/simplefactory/</link>
      <pubDate>Wed, 24 Jul 2019 10:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/simplefactory/</guid>
      <description>引入 实现计算器 代码实现 1 实现一个基础的计算器功能，代码见https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/calculator01.php
问题分析 （1）错误处理只判断了除数是否为0，对于字符超长，不可计算等都未处理，可以加上try catch； （2）代码不可复用，耦合性很高
使用面向对象处理 （1）使用面向对象的方式实现，将输入输出流和逻辑代码分离，可以提高代码复用性，降低耦合，代码见https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/Calculate2.php
紧耦合vs松耦合 思考：什么情况下使用继承和多态（各种运算可以继承自运算基类，便于扩展，多态考虑输入的不同类型，对于字符串怎样运算） 根据以上思考，完成有继承和多态的代码如下： https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/Calculate03.php 思考：以上代码实现方式虽然使用到了继承，但是如何知道应该调用哪个类呢？难道像之前预估的一样，还是要使用switch判断？
简单工厂模式 解决问题，实例化谁，将来会不会增加实例化的对象等容易变化的地方，考虑用一个单独的类来做这个创造实例的过程 在此基础上实现一个简单工厂类，代码如下： https://github.com/laurel-he/design_pattern/blob/master/simpleFactory/Calculate04.php 如果需要修改运算，可以只修改对应的类，如果需要添加运算，只需要添加运算类，并在工厂中添加对应的分支就可以了 简单工厂模式的工厂类一般是使用静态方法，通过接受的参数的不同来返回不同的对象实例
工厂方法模式 1 简单工厂模式优点： （1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离； （2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可； （3）在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性 2 简单工厂模式缺点： （1）工厂类职责过重，它出问题整个系统都会崩溃 （2）添加新的类的时候，系统中的简单工厂类都要修改，违反了开放-封闭原则 （3）简单工厂的静态方法，使得工厂角色无法形成基于继承的等级结构 工厂方法模式每一种算法都对应一种工厂， 工厂方法模式优点： （1）
抽象工厂 </description>
    </item>
    
    <item>
      <title>抽象工厂模式</title>
      <link>https://laurel-he.github.io/designpattern/phpallpattern/abstractfactory/</link>
      <pubDate>Mon, 22 Jul 2019 17:40:10 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/designpattern/phpallpattern/abstractfactory/</guid>
      <description>目的 在不指定具体类的情况下创建一系列相关或依赖对象。 通常创建的类都实现相同的接口。 抽象工厂的客户并不关心这些对象是如何创建的，它只是知道它们是如何一起运行的。
举例  &amp;lt;?php class KuaidiBirdLogic extends BaseLogic { private $basic; private $num; public function __construct(int $num, int $basic) { $this-&amp;gt;num = $num; $this-&amp;gt;basic = $basic; } } class KuaidiOneLogic implements KuaidiBase { private $num; public function __construct(int $num) { $this-&amp;gt;num = $num; } } 定义抽象工厂类
&amp;lt;?php class ExpressFactory extends Model { public function getKuaidiBirdList() { return new KuaidiBirdLogic(12, 13); } public function getKuaidiOneLogic() { return new KuaidiOneLogic(); } } 几种工厂模式的区别 抽象工厂模式 类似于示例Basic</description>
    </item>
    
  </channel>
</rss>
