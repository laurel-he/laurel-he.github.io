<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Databases on </title>
    <link>https://laurel-he.github.io/database/</link>
    <description>Recent content in Databases on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 20 Nov 2021 18:27:44 +0000</lastBuildDate><atom:link href="https://laurel-he.github.io/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>php下es基本使用</title>
      <link>https://laurel-he.github.io/database/es/basic/</link>
      <pubDate>Sat, 20 Nov 2021 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/es/basic/</guid>
      <description>本文参考文档: es7.3文档 全文搜索引擎 Elasticsearch 入门教程
基础介绍 全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。
安装 不同环境下安装方式不同，可以采用下载安装包，apt-get，yum安装等各种方法，在wsl下linux安装需要注意，wsl下的Linux系统没有使用systemd，可以尝试用SysV init的命令代替systemd，或者安装systemd命令 安装完后直接执行curl localhost:9200可以获取到es基本信息，例如我执行后结果如下：
{ &amp;#34;name&amp;#34; : &amp;#34;MS-RWTYITLHLCWO&amp;#34;, &amp;#34;cluster_name&amp;#34; : &amp;#34;elasticsearch&amp;#34;, &amp;#34;cluster_uuid&amp;#34; : &amp;#34;j9WVJcIFRq6bEa3bwXCARA&amp;#34;, &amp;#34;version&amp;#34; : { &amp;#34;number&amp;#34; : &amp;#34;7.15.2&amp;#34;, &amp;#34;build_flavor&amp;#34; : &amp;#34;default&amp;#34;, &amp;#34;build_type&amp;#34; : &amp;#34;deb&amp;#34;, &amp;#34;build_hash&amp;#34; : &amp;#34;93d5a7f6192e8a1a12e154a2b81bf6fa7309da0c&amp;#34;, &amp;#34;build_date&amp;#34; : &amp;#34;2021-11-04T14:04:42.515624022Z&amp;#34;, &amp;#34;build_snapshot&amp;#34; : false, &amp;#34;lucene_version&amp;#34; : &amp;#34;8.9.0&amp;#34;, &amp;#34;minimum_wire_compatibility_version&amp;#34; : &amp;#34;6.8.0&amp;#34;, &amp;#34;minimum_index_compatibility_version&amp;#34; : &amp;#34;6.0.0-beta1&amp;#34; }, &amp;#34;tagline&amp;#34; : &amp;#34;You Know, for Search&amp;#34; } 使用 引入包 正常通过Restful API方式使用在各个文档中都有详细介绍，在此省略，说一下在php中如何使用。 在laravel或yii2等主流框架中都有自己使用es的包，例如yiisoft/yii2-elasticsearch或basemkhirat/elasticsearch等等，但假设使用的是自研框架呢？ 目前我使用的是基于swoole开发的自研框架，引入了elasticsearch/elasticsearch包，在composer require elasticsearch/elasticsearch时，会自动根据php版本引入包
配置 连接池 </description>
    </item>
    
    <item>
      <title>mongodb学习记录</title>
      <link>https://laurel-he.github.io/database/mongo/mongocomplex/</link>
      <pubDate>Sun, 20 Oct 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mongo/mongocomplex/</guid>
      <description>参考文档 http://www.mongoing.com/docs/reference/operator/aggregation/interface.html https://www.cnblogs.com/zhoujie/p/mongo1.html https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/tutorial-text-search-in-aggregation.html
mongodb精准匹配 假设有需求如下：数据为多层级的数组，需要精准匹配到某一个层级，并进行更新或新增等操作，如何实现？
实现方式 当Mongodb版本大于3.6.1，实现将会非常简单，因为mongodb3.6.1以上可以直接通过语句来实现精准匹配。 但由于实际场景中版本不支持，当匹配超过一级则会报错：Too many positional (i.e. &amp;lsquo;$&#39;) elements found in path &amp;lsquo;files.$.testConstruct.params.list.$.testRange&amp;rsquo; 当版本大于3.6.1，举例：
db.test_db.update( {&#39;_id&#39;: {$in: [&#39;1242rererwwr&#39;]}, &#39;files.name&#39;: &#39;test1.json&#39;, &#39;files.testConstruct.params.list.type&#39;: &#39;NewData&#39;}, {$set: {&#39;files.$.structuredContent.params.list.$.testRange&#39;: {&#39;enable&#39;: false, &#39;min&#39;: 14, &#39;max&#39;: 90}}, $currentDate: { updatedDatetime: true }}, { multi: true }) 分析： 设置值时，&amp;lsquo;files.$.testConstruct.params.list.$.testRange&amp;rsquo;中的第一个&amp;quot;$&amp;ldquo;将会匹配到name=test1.json的数组，第二个&amp;rdquo;$&amp;ldquo;将会匹配到files.structuredContent.params.list.type=NewData的数组 优点： 使用简单，匹配精确，无需代码判断 缺点： 适用版本有限制，且由于多级匹配需要更多的条件，而实际业务中不一定能取到这些条件（例如知道要更新的key为testRange但是不知道上级查询条件无法匹配到） 如果版本过低，可只匹配第一级，其余的通过代码匹配。 当版本小于3.6.1举例：
&amp;lt;?php public function batchUpdateContents(string $route, array $ids, string $editor, $updateItems, bool $needPublish): bool { $routes = explode(&amp;#39;-&amp;#39;, $route); array_shift($routes); $routes[2] = self::TYPE_LIST[$routes[2]]; $updateRoute = &amp;#39;files.</description>
    </item>
    
    <item>
      <title>Mysql分库分表</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmerge/</link>
      <pubDate>Mon, 08 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmerge/</guid>
      <description>本文参考MySQL：互联网公司常用分库分表方案汇总！
水平分割和垂直分割 把表数据分成多少多少条，叫做水平分割 表的字段很长，把部分大字段分到另外一个表中，叫垂直分割
瓶颈 IO瓶颈 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&amp;gt; 分库和垂直分表。 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&amp;gt; 分库。
CPU瓶颈 第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&amp;gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。 第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&amp;gt; 水平分表。
分库分表 水平分库 概念 以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
示例 假设是电商场景，根据不同的公司，分成不同的表
结果 每个库的结构都一样； 每个库的数据都不一样，没有交集； 所有库的并集是全量数据；
场景 系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
分析 库多了，io和cpu的压力自然可以成倍缓解。
水平分表 概念 以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
示例 假设数据库中存在一个字段：学号:stu_num，可以按照尾号为0-9分成9个库
结果 每个表的结构都一样； 每个表的数据都不一样，没有交集； 所有表的并集是全量数据；
场景 系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。
分析 表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。
垂直分库 概念 以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
示例 电商包括订单，用户，物流等模块，前期都放在同一个库里，后期不同的模块使用不同的库
结果 每个库的结构都不一样； 每个库的数据也不一样，没有交集； 所有库的并集是全量数据；
场景 系统绝对并发量上来了，并且可以抽象出单独的业务模块。
分析 到这一步，基本上就可以服务化了。 例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。 再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。
垂直分表 概念 以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。
结果 每个表的结构都不一样； 每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据； 所有表的并集是全量数据；</description>
    </item>
    
    <item>
      <title>mysql必知必会学习笔记-2-检索数据</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmustknown_02/</link>
      <pubDate>Wed, 03 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmustknown_02/</guid>
      <description>select语句 -- 简单的查询 select prod_name from ta_name; -- 查询几个列 select prod_id, prod_name from tb_name; -- 查询所有列，一般不建议，检索不需要的列通常会降低检索和应用程序的性能 select * from tb_name; -- 只返回不同的值 select distinct xxx_id from tb_name; -- 返回前5行 select prod_name from tb_name limit 5; -- 限制开始行和行数，例如从第3行开始，返回5行 select prod_name from tb_name limit 3,5; -- 从Mysql5开始，从第3行返回5行可以写作： select prod_mame from tb_name limit 5 OFFSET 3; 注意事项 （1）在原书中有这么一段话：
 不能部分使用DISTINCT。DISTINCT关键字应用于所有列而 不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被 检索出来
 我自己建表试过，翻译一下就是，一般来说DISTINCT用于单列的去重，当用于多列的时候，当这两个列的值完全一样时会被去重，当其中一个值或者以上不同时，不会被去重。
（2）第一行是行0, limit 1,1实际上返回的是第2行数据。带一个值的返回的是第0行，也就是人眼看到的第一行的数据。
排序检索数据 关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。
示例：</description>
    </item>
    
    <item>
      <title>mongodb使用</title>
      <link>https://laurel-he.github.io/database/mongo/mongo1/</link>
      <pubDate>Tue, 02 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mongo/mongo1/</guid>
      <description>基础  列出所有数据库:show dbs; 列出所有表：show tables;或show collections; 查询所有数据：db.taname.find().pretty(); 查询指定列所有数据：db.tbname.find({},{col1:1,col2:2,&amp;hellip;}).pretty(); 根据条件查询所有数据：db.tbname.find({name:&amp;ldquo;test&amp;rdquo;},{col1:1,col2:1}).pretty(); 查询结果不包含指定字段：db.tbname.find({},{status:0,col2:0}).pretty();  查询 1 查询所有数据 db.tbname.find().pretty();</description>
    </item>
    
    <item>
      <title>mysql必知必会学习笔记-1-基础概念</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</link>
      <pubDate>Tue, 02 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlmustknown_01/</guid>
      <description>基础复习 本书大概通读了一遍，内容几乎都是我知道或者学过的，但是我依然想再详细阅读一遍，并且跟着书中的示例来实际操作下，打牢基础。以下是学习笔记。
概念 定义 数据库 数据库是用来保存有组织的数据的容器
表 某种特定类型数据的结构化清单（在类似mongodb等nosql数据库中，表的类型和字段都不是固定的）
列 表中的一个字段，所有的表都是由一个或多个列组成的
数据类型 所容许的数据类型，每个表列都有相应的数据类型，它限制或容许改列中存储的数据
行 表中的一条记录
主键 一列（或一组列），其值能够唯一区分表中的每一行 主键建议 （1）不更新主键列中的值 （2）不重用组件列的值 （3）不在主键列中使用可能会更改的值
模式 关于数据库和表的布局及特性的信息。
分类 DBMS分为两种，一类为基于共享文件系统的DBMS，另一类为基于客户机—服务器的DBMS。
客户机-服务器 与数据文件打交道的只有服务器软件。关于数据、数据添加、删除 和数据更新的所有请求都由服务器软件完成。这些请求或更改来自运行 客户机软件的计算机。客户机是与用户打交道的软件。例如，如果你请 求一个按字母顺序列出的产品表，则客户机软件通过网络提交该请求给 服务器软件。服务器软件处理这个请求，根据需要过滤、丢弃和排序数 据；然后把结果送回到你的客户机软件。
使用 mysql命令行连接参数 经常使用的参数:
   参数 解释     u 用户名   h host   P 端口号   p 密码    一些基础命令 -- 选择数据库 use db_name; -- 查看所有数据库 show databases; -- 查看所有表 SHOW TABLES; -- 显示表列 SHOW COLUMNS FROM tb_name; desc tb_name; describe tb_name; -- 显示广泛的服务器状态信息 SHOW STATUS; -- 显示创建数据库的信息 show create database db_name; -- 显示创建表的信息 show create table tb_name; -- 显示授权用户的安全权限 SHOW GRANTS; -- 显示服务器错误或警告信息 show errors; show warnings; -- 显示允许使用的show语句 help show; </description>
    </item>
    
    <item>
      <title>mysql索引优化</title>
      <link>https://laurel-he.github.io/database/mysql/mysqlindex/</link>
      <pubDate>Tue, 02 Apr 2019 18:27:44 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysqlindex/</guid>
      <description>1 查看查询语句执行效率 语法 explain select … from … [where &amp;hellip;] 示例
explain select * from news; 只查询一行数据： 查询多行数据：执行查询 执行explain: 2 属性详解    属性 作用     id SELECT的查询序列号   select_type SELECT的查询序列号   table 显示这一行的数据是关于哪张表的   type 显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一   possible_keys 指出MySQL能使用哪个索引在该表中找到行   key 显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL   key_len 显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好   ref 显示使用哪个列或常数与key一起从表中选择行   rows 显示MySQL认为它执行查询时必须检查的行数   Extra 包含MySQL解决查询的详细信息，也是关键参考项之一   select_type        类型 解释     SIMPLE 简单SELECT(不使用UNION或子查询等)   PRIMARY 最外面的SELECT   UNION UNION中的第二个或后面的SELECT语句   DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询   UNION RESULT UNION的结果   SUBQUERY 子查询中的第一个SELECT   DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询   DERIVED 导出表的SELECT(FROM子句的子查询)   type     索引从好到坏依次是：</description>
    </item>
    
    <item>
      <title>mysql数据库维护</title>
      <link>https://laurel-he.github.io/database/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</link>
      <pubDate>Thu, 28 Mar 2019 14:03:27 +0000</pubDate>
      
      <guid>https://laurel-he.github.io/database/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
